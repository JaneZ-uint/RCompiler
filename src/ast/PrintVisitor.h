# pragma once

#include <iostream>
#include <optional>
#include "Expression/expression.h"
#include "astvisitor.h"
#include "root.h"
#include "Expression/ExprArray.h"
#include "Expression/ExprBlock.h"
#include "Expression/ExprBreak.h"
#include "Expression/ExprCall.h"
#include "Expression/ExprContinue.h"
#include "Expression/ExprField.h"
#include "Expression/ExprGroup.h"
#include "Expression/ExprIf.h"
#include "Expression/ExprIndex.h"
#include "Expression/ExprLiteral.h"
#include "Expression/ExprLoop.h"
#include "Expression/ExprMatch.h"
#include "Expression/ExprMethodcall.h"
#include "Expression/ExprOpbinary.h"
#include "Expression/ExprOpunary.h"
#include "Expression/ExprPath.h"
#include "Expression/ExprReturn.h"
#include "Expression/ExprUnderscore.h"
#include "Item/ItemConst.h"
#include "Item/ItemEnum.h"
#include "Item/ItemFn.h"
#include "Item/ItemImpl.h"
#include "Item/ItemStruct.h"
#include "Item/ItemTrait.h"
#include "Pattern/PatternIdentifier.h"
#include "Pattern/PatternLiteral.h"
#include "Pattern/PatternPath.h"
#include "Pattern/PatternReference.h"
#include "Pattern/PatternTupleStruct.h"
#include "Pattern/PatternWildcard.h"
#include "Statement/StmtEmpty.h"
#include "Statement/StmtExpr.h"
#include "Statement/StmtItem.h"
#include "Statement/StmtLet.h"
#include "Type/type.h"
#include "Type/TypeArray.h"
#include "Type/TypePath.h"
#include "Type/TypeReference.h"
#include "Type/TypeUnit.h"

namespace JaneZ {
class PrintVisitor : public ASTVisitor{
public:
    ~PrintVisitor() = default;

    //Start: generated by github copilot.
    void visit(ASTNode &node) override{
        if(auto *p = dynamic_cast<ASTRootNode *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<Expression *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<Item *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<Pattern *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<Statement *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<Type *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<TypeArray *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<TypePath *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<TypeReference *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<TypeUnit *>(& node)) {
            visit(*p);
        }else{
            std::cout << "Unknown node type in PrintVisitor\n";
        }
    }
    //End: generated by github copilot.

    void visit(ASTRootNode &node) override {
        std::cout << "ASTRootNode\n";
        for(auto &item : node.child) {
            item->accept(*this);
        }
        std::cout << "End of ASTRootNode\n";
    }

    //Expression
    void visit(Expression &node) override {
        if(auto *p = dynamic_cast<ExprArray *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<ExprBlock *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<ExprBreak *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<ExprCall *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<ExprContinue *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<ExprField *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<ExprGroup *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<ExprIf *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<ExprIndex *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<ExprLiteral *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<ExprLoop *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<ExprMatch *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<ExprMethodcall *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<ExprOpbinary *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<ExprOpunary *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<ExprPath *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<ExprReturn *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<ExprUnderscore *>(& node)) {
            visit(*p);
        }else{
            std::cout << "Unknown Expression type in PrintVisitor\n";
        }
    }

    void visit(ExprArray &node) override{
        std::cout << "ExprArray: ";
        if(node.arrayExpr.size() > 0) {
            for(auto &expr : node.arrayExpr) {
                expr->accept(*this);
                std::cout << ", ";
            }
            std::cout << "\n";
        }else{
            node.size->accept(*this);
            std::cout << ";";
            node.type->accept(*this);
            std::cout << "\n";
        }
    }

    void visit(ExprBlock &node) override{
        std::cout << "ExprBlock {\n";
        if(node.statements.size() > 0){
            for(auto &stmt : node.statements) {
                stmt->accept(*this);
            }
        }
        if(node.ExpressionWithoutBlock){
            node.ExpressionWithoutBlock->accept(*this);
        }
        std::cout << "}\n";
    }

    void visit(ExprBreak &node) override{
        std::cout << "ExprBreak\n";
    }

    void visit(ExprCall &node) override{
        std::cout << "ExprCall: ";
        node.expr->accept(*this);
        if(node.callParams.size() > 0) {
            std::cout << "(";
            for(auto &param : node.callParams) {
                param->accept(*this);
                std::cout << ", ";
            }
            std::cout << ")";
        }
        std::cout << "\n";
    }

    void visit(ExprContinue &node) override{
        std::cout << "ExprContinue\n";
    }

    void visit(ExprField &node) override{
        std::cout << "ExprField: ";
        node.expr->accept(*this);
        std::cout << "." << node.identifier << "\n";
    }

    void visit(ExprGroup &node) override{
        std::cout << "ExprGroup: (";
        node.expr->accept(*this);
        std::cout << ")\n";
    }

    void visit(ExprIf &node) override{
        std::cout << "ExprIf: if (";
        node.condition->accept(*this);
        std::cout << ") ";
        std::cout << "{ \n";
        node.thenBlock->accept(*this);
        std::cout << " } \n";
        if(node.elseBlock) {
            std::cout << " else ";
            node.elseBlock->accept(*this);
        }
        std::cout << "\n";
    }

    void visit(ExprIndex &node) override{
        std::cout << "ExprIndex: ";
        node.name->accept(*this);
        std::cout << "[";
        node.index->accept(*this);
        std::cout << "]\n";
    }

    void visit(ExprLiteral &node) override{
        std::cout << "ExprLiteral: " << node.literal << " ";
        if(node.type == CHAR_LITERAL) {
            std::cout << "(char)\n";
        }else if(node.type == STRING_LITERAL) {
            std::cout << "(string)\n";
        }else if(node.type == RAW_STRING_LITERAL) { 
            std::cout << "(raw string)\n";
        }else if(node.type == C_STRING_LITERAL) {
            std::cout << "(C string)\n";
        }else if(node.type == RAW_C_STRING_LITERAL) {
            std::cout << "(raw C string)\n";
        }else if(node.type == INTEGER_LITERAL) {
            std::cout << "(integer)\n";
        }else if(node.type == TRUE) {
            std::cout << "(true)\n";
        }else if(node.type == FALSE) {
            std::cout << "(false)\n";
        }else{
            std::cout << "(unknown literal type)\n";
        }
    }

    void visit(ExprLoop &node) override{
        std::cout << "ExprLoop: loop { \n";
        if(node.infinitieLoop){
            node.infinitieLoop->accept(*this);
        }else{
            if(node.condition){
                std::cout << "while (";
                node.condition->accept(*this);
                std::cout << ") ";
            }
            if(node.PredicateLoopExpression){
                node.PredicateLoopExpression->accept(*this);
            }
        }
        std::cout << "}\n";
    }

    void visit(ExprMatch &node) override{
        //NO Match
    }

    void visit(ExprMethodcall &node) override{
        std::cout << "ExprMethodcall: ";
        node.expr->accept(*this);
        std::cout << "." <<" ";
        node.PathExprSegment->accept(*this);
        std::cout << "(";
        if(node.callParams.size() > 0) {
            for(auto &param : node.callParams) {
                param->accept(*this);
                std::cout << ", ";
            }
        }
        std::cout << ")\n";
    }

    void visit(ExprOpbinary &node) override{
        std::cout << "ExprOpbinary: ";
        node.left->accept(*this);
        std::cout << " " << node.op << " ";
        node.right->accept(*this);
        std::cout << "\n";
    }

    void visit(ExprOpunary &node) override{
        std::cout << "ExprOpunary: " << node.op << " ";
        node.right->accept(*this);
        std::cout << "\n";
    }

    void visit(ExprPath &node) override{
        std::cout << "ExprPath: ";
        node.pathFirst->accept(*this);
        std::cout << ":: ";
        if(node.pathSecond){
            node.pathSecond->accept(*this);
        }
        std::cout << "\n";
    }

    void visit(ExprReturn &node) override{
        std::cout << "ExprReturn: return ";
        if(node.expr){
            node.expr->accept(*this);
        }
        std::cout << "\n";
    }

    void visit(ExprUnderscore &node) override{
        std::cout << "ExprUnderscore: _\n";
    }
    
    //Item
    void visit(Item &node) override {
        if(auto *p = dynamic_cast<ItemConstDecl *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<ItemEnumDecl *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<ItemFnDecl *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<ItemImplDecl *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<ItemStructDecl *>(& node)) {    
            visit(*p);
        }else if(auto *p = dynamic_cast<ItemTraitDecl *>(& node)) {
            visit(*p);
        }else{
            std::cout << "Unknown Item type in PrintVisitor\n";
        }
    }

    void visit(ItemConstDecl &node) override{
        std::cout << "ItemConstDecl: const " << node.identifier << ": ";
        node.type->accept(*this);
        std::cout << " = ";
        if(node.expr){
            node.expr->accept(*this);
        }
        std::cout << "\n";
    }

    void visit(ItemEnumDecl &node) override{
        std::cout << "ItemEnumDecl: enum " << node.identifier << " {\n";
        if(node.item_enum.size() == 0) {
            std::cout << "Empty enum\n";
        }else{
            for(auto &var : node.item_enum) {
                std::cout << "Variant: " << var << " ";
                std::cout << "\n";
            }
        }
        std::cout << "}\n";
    }

    void visit(ItemFnDecl &node) override{
        std::cout << "ItemFnDecl: fn ";
        if(node.is_const) {
            std::cout << "const ";
        }
        std::cout << node.identifier << "(";
        if(node.fnParameters.SelfParam.type_self.type) {
            node.fnParameters.SelfParam.type_self.type->accept(*this);
        }else{
            if(node.fnParameters.SelfParam.short_self.is_and) {
                std::cout << "&";
            }
            if(node.fnParameters.SelfParam.short_self.is_mut) {
                std::cout << "mut ";
            }
            std::cout << "self";
        }
        if(node.fnParameters.FunctionParam.size() > 0) {
            for(auto &param : node.fnParameters.FunctionParam) {
                param.pattern->accept(*this);
                std::cout << ": ";
                param.type->accept(*this);
                std::cout << ", ";
            }
        }
        std::cout << ") -> ";
        node.returnType->accept(*this);
        std::cout << " {\n";
        if(node.fnBody){
            node.fnBody->accept(*this);
        }
        std::cout << "}\n";
    }

    void visit(ItemImplDecl &node) override{
        std::cout << "ItemImplDecl: impl ";
        if(node.identifier != "") {
            std::cout << node.identifier << " for ";
            node.targetType->accept(*this);
            std::cout << " {\n";
            if(node.item_trait_const.size() > 0) {
                for(auto &const_item : node.item_trait_const) {
                    const_item->accept(*this);
                }
            }
            if(node.item_trait_fn.size() > 0) {
                for(auto &fn_item : node.item_trait_fn) {
                    fn_item->accept(*this);
                }
            }
            std::cout << "}\n";
        }else{
            std::cout << "for ";
            node.targetType->accept(*this);
            std::cout << " {\n";
            if(node.item_trait_const.size() > 0) {
                for(auto &const_item : node.item_trait_const) {
                    const_item->accept(*this);
                }
            }
            if(node.item_trait_fn.size() > 0) {
                for(auto &fn_item : node.item_trait_fn) {
                    fn_item->accept(*this);
                }
            }
            std::cout << "}\n";
        }
        std::cout << "}\n";
    }

    void visit(ItemStructDecl &node) override{
        std::cout << "ItemStructDecl: struct " << node.identifier << " {\n";
        if(node.item_struct.size() == 0) {
            std::cout << "Empty struct\n";
        }else{
            for(auto &field : node.item_struct) {
                std::cout << field.identifier << ": ";
                field.structElem->accept(*this);
                std::cout << ",\n";
            }
        }
        std::cout << "}\n";
    }

    void visit(ItemTraitDecl &node) override{
        std::cout << "ItemTraitDecl: trait " << node.identifier << " {\n";
        if(node.item_trait_const.size() > 0) {
            for(auto &const_item : node.item_trait_const) {
                const_item->accept(*this);
            }
        }
        if(node.item_trait_fn.size() > 0) {
            for(auto &fn_item : node.item_trait_fn) {
                fn_item->accept(*this);
            }
        }
        std::cout << "}\n";
    }

    //Pattern
    void visit(Pattern &node) override {
        if(auto *p = dynamic_cast<PatternIdentifier *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<PatternLiteral *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<PatternPath *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<PatternReference *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<PatternWildCard *>(& node)) {   
            visit(*p);
        }else if(auto *p = dynamic_cast<PatternTupleStruct *>(& node)) {
            visit(*p);
        }else{
            std::cout << "Unknown Pattern type in PrintVisitor\n";
        }
    }
    void visit(PatternIdentifier &node) override{
        std::cout << "PatternIdentifier: ";
        if(node.is_ref) {
            std::cout << "&";
        }
        if(node.is_mut) {
            std::cout << "mut ";
        }
        std::cout << node.identifier << "\n";
    }

    /*void visit(PatternTupleStruct &node) override{
        //No Match
    }*/

    void visit(PatternLiteral &node) override{
        std::cout << "PatternLiteral: ";
        if(node.isMinus){
            std::cout << "- ";
        }
        node.pattern_literal->accept(*this);
        std::cout << "\n";
    }

    void visit(PatternPath &node) override{
        std::cout << "PatternPath: ";
        node.path->accept(*this);
        std::cout << "\n";
    }

    void visit(PatternReference &node) override{
        std::cout << "PatternReference: ";
        if(node.isANDAND) {
            std::cout << "&& ";
        }else{
            std::cout << "& ";
        }
        if(node.is_mut) {
            std::cout << "mut ";
        }
        if(node.patternWithoutRange) {
            node.patternWithoutRange->accept(*this);
        }
        std::cout << "\n";
    }

    void visit(PatternWildCard &node) override{
        std::cout << "PatternWildCard: ";
        std::cout << "_";
        std::cout << "\n";
    }

    //Statement
    void visit(Statement &node) override {
        if(auto *p = dynamic_cast<StmtEmpty *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<StmtExpr *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<StmtItem *>(& node)) {
            visit(*p);
        }else if(auto *p = dynamic_cast<StmtLet *>(& node)) {
            visit(*p);
        }else{
            std::cout << "Unknown Statement type in PrintVisitor\n";
        }
    }
    void visit(StmtEmpty &node) override{
        std::cout << "StmtEmpty: ";
        std::cout << ";\n";
    }

    void visit(StmtExpr &node) override{
        std::cout << "StmtExpr: ";
        node.stmtExpr->accept(*this);
        std::cout << "\n";
    }

    void visit(StmtItem &node) override{
        std::cout << "StmtItem: ";
        node.stmt_item->accept(*this);
        std::cout << "\n";
    }

    void visit(StmtLet &node) override{
        std::cout << "StmtLet: ";
        std::cout << "Let ";
        node.PatternNoTopAlt->accept(*this);
        std::cout << ":";
        node.type->accept(*this);
        if(node.expression){
            std::cout << "=";
            node.expression->accept(*this);
        }
        std::cout << ";\n";
    }

    //Type
    void visit(Type &node) override{
        std::cout << "Type: ";
        if(node.type == BOOL) {
            std::cout << "bool\n";
        }else if(node.type == U32) {
            std::cout << "u32\n";
        }else if(node.type == I32) {
            std::cout << "i32\n";
        }else if(node.type == USIZE) {
            std::cout << "usize\n";
        }else if(node.type == ISIZE) {
            std::cout << "isize\n";
        }else if(node.type == CHAR) {
            std::cout << "char\n";
        }else if(node.type == STR) {
            std::cout << "str\n";
        }else if(node.type == ENUM) {
            std::cout << "enum\n";
        }else{
            std::cout << "unknown type\n";
        }
    }

    void visit(TypeArray &node) override{
        std::cout << "TypeArray: [";
        node.type->accept(*this);
        std::cout << "; ";
        node.expr->accept(*this);
        std::cout << "]\n";
    }

    void visit(TypePath &node) override{
        std::cout << "TypePath: ";
        node.typePath->accept(*this);
        std::cout << "\n";
    }

    void visit(TypeReference &node) override{
        std::cout << "TypeReference: &";
        if(node.is_mut) {
            std::cout << "mut ";
        }
        node.typeNoBounds->accept(*this);
        std::cout << "\n";
    }
    
    void visit(TypeUnit &node) override{
        std::cout << "TypeUnit: ()\n";
    }

    //Path
    void visit(Path &node) override;
};
}