# pragma once

#include "../ast/astvisitor.h"
#include "../ast/Expression/ExprConstBlock.h"
#include "../ast/Expression/ExprStruct.h"
#include "../ast/Expression/expression.h"
#include "../ast/root.h"
#include "../ast/Expression/ExprArray.h"
#include "../ast/Expression/ExprBlock.h"
#include "../ast/Expression/ExprBreak.h"
#include "../ast/Expression/ExprCall.h"
#include "../ast/Expression/ExprContinue.h"
#include "../ast/Expression/ExprField.h"
#include "../ast/Expression/ExprGroup.h"
#include "../ast/Expression/ExprIf.h"
#include "../ast/Expression/ExprIndex.h"
#include "../ast/Expression/ExprLiteral.h"
#include "../ast/Expression/ExprLoop.h"
#include "../ast/Expression/ExprMatch.h"
#include "../ast/Expression/ExprMethodcall.h"
#include "../ast/Expression/ExprOpbinary.h"
#include "../ast/Expression/ExprOpunary.h"
#include "../ast/Expression/ExprPath.h"
#include "../ast/Expression/ExprReturn.h"
#include "../ast/Expression/ExprUnderscore.h"
#include "../ast/Item/ItemConst.h"
#include "../ast/Item/ItemEnum.h"
#include "../ast/Item/ItemFn.h"
#include "../ast/Item/ItemImpl.h"
#include "../ast/Item/ItemStruct.h"
#include "../ast/Item/ItemTrait.h"
#include "../ast/Pattern/PatternIdentifier.h"
#include "../ast/Pattern/PatternLiteral.h"
#include "../ast/Pattern/PatternPath.h"
#include "../ast/Pattern/PatternReference.h"
#include "../ast/Pattern/PatternTupleStruct.h"
#include "../ast/Pattern/PatternWildcard.h"
#include "../ast/Statement/StmtEmpty.h"
#include "../ast/Statement/StmtExpr.h"
#include "../ast/Statement/StmtItem.h"
#include "../ast/Statement/StmtLet.h"
#include "../ast/Type/type.h"
#include "../ast/Type/TypeArray.h"
#include "../ast/Type/TypePath.h"
#include "../ast/Type/TypeReference.h"
#include "../ast/Type/TypeUnit.h"
#include "globalScope.h"
#include "scope.h"
#include "symbol.h"
#include <iostream>
#include <memory>

// part generated by github copilot.
namespace JaneZ {
class NameResolver : public ASTVisitor{
public:
    std::shared_ptr<ScopeNode> current_scope;

    GlobalScopeBuilder global_scope_builder;

    NameResolver() = default;

    ~NameResolver() = default;
    
    //Start: generated by github copilot.
    void visit(ASTNode &node) override {
        if(auto *p = dynamic_cast<ASTRootNode *>(& node)) {
            node.accept(*this);
        }else if(auto *p = dynamic_cast<Expression *>(& node)) {
            node.accept(*this);
        }else if(auto *p = dynamic_cast<Item *>(& node)) {
            node.accept(*this);
        }else if(auto *p = dynamic_cast<Pattern *>(& node)) {
            node.accept(*this);
        }else if(auto *p = dynamic_cast<Statement *>(& node)) {
            node.accept(*this);
        }else if(auto *p = dynamic_cast<Type *>(& node)) {
            node.accept(*this);
        }else if(auto *p = dynamic_cast<TypeArray *>(& node)) {
            node.accept(*this);
        }else if(auto *p = dynamic_cast<TypePath *>(& node)) {
            node.accept(*this);
        }else if(auto *p = dynamic_cast<TypeReference *>(& node)) {
            node.accept(*this);
        }else if(auto *p = dynamic_cast<TypeUnit *>(& node)) {
            node.accept(*this);
        }else{
            std::cout << "Unknown node type in PrintVisitor\n";
        }
    }
    //End: generated by github copilot.

    void visit(ASTRootNode &node) override {
        current_scope = global_scope_builder.global_scope;
        for(auto &item : node.child) {
            //item->accept(*this);
            visit(*item);
        }
    }

    //Expression
    void visit(Expression &node) override {
        if(auto *p = dynamic_cast<ExprArray *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprBlock *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprBreak *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprCall *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprConstBlock *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprContinue *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprField *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprGroup *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprIf *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprIndex *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprLiteral *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprLoop *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprMatch *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprMethodcall *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprOpbinary *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprOpunary *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprPath *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprReturn *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprStruct *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprUnderscore *>(& node)) {
            p->accept(*this);
        }else{
            std::cout << "Unknown Expression type in PrintVisitor\n";
        }
    }

    void visit(ExprArray &node) override{
        if(node.arrayExpr.size() > 0) {
            for(auto &expr : node.arrayExpr) {
                expr->accept(*this);
            }
        }else{
            node.size->accept(*this);
            node.type->accept(*this);
        }
    }

    void visit(ExprBlock &node) override{
        if(node.statements.size() > 0){
            for(auto &stmt : node.statements) {
                stmt->accept(*this);
            }
        }
        if(node.ExpressionWithoutBlock){
            node.ExpressionWithoutBlock->accept(*this);
        }
    }

    void visit(ExprBreak &node) override{}

    void visit(ExprCall &node) override{
        //todo may check function param type
        if(auto *p = dynamic_cast<ExprPath *>(& *node.expr)) {
            if(p->pathSecond){
                if(p->pathFirst->pathSegments.type == IDENTIFIER) {
                    auto symbol = current_scope->lookupTypeSymbol(p->pathFirst->pathSegments.identifier);
                    if(!symbol) {
                        throw std::runtime_error("Type symbol not found: " + p->pathFirst->pathSegments.identifier);
                    }else{
                        p->resolvedSymbol1 = symbol; 
                    }
                    if(symbol->symbol_type == Struct){
                        auto structSymbol = std::dynamic_pointer_cast<StructSymbol>(symbol);
                        if(structSymbol->methods.find(p->pathSecond->pathSegments.identifier) == structSymbol->methods.end()){
                            throw std::runtime_error("Method not found in struct: " + p->pathSecond->pathSegments.identifier);
                        }
                    }else if(symbol->symbol_type == Trait){
                        auto traitSymbol = std::dynamic_pointer_cast<TraitSymbol>(symbol);
                        if(traitSymbol->methods.find(p->pathSecond->pathSegments.identifier) == traitSymbol->methods.end()){
                            throw std::runtime_error("Method not found in trait: " + p->pathSecond->pathSegments.identifier);
                        }
                    }else{
                        throw std::runtime_error("Type is not a struct or trait: " + p->pathFirst->pathSegments.identifier);
                    }
                }
            }else{
                auto symbol = current_scope->lookupValueSymbol(p->pathFirst->pathSegments.identifier);
                if(symbol->symbol_type == Function){
                    p->resolvedSymbol1 = symbol;
                }else{
                    throw std::runtime_error("Value symbol is not a function: " + p->pathFirst->pathSegments.identifier);
                }
            }
        }
        if(node.callParams.size() > 0) {
            for(auto &param : node.callParams) {
                param->accept(*this);
            }
        }
    }

    void visit(ExprConstBlock &node) override{
        node.expr->accept(*this);
    }

    void visit(ExprContinue &node) override{}

    void visit(ExprField &node) override{
        node.expr->accept(*this);
    }

    void visit(ExprGroup &node) override{
        node.expr->accept(*this);
    }

    void visit(ExprIf &node) override{
        node.condition->accept(*this);
        node.thenBlock->accept(*this);
        if(node.elseBlock){
            node.elseBlock->accept(*this);
        }
    }

    void visit(ExprIndex &node) override{
        node.name->accept(*this);
        node.index->accept(*this);
    }

    void visit(ExprLiteral &node) override{}

    void visit(ExprLoop &node) override{
        if(node.infinitieLoop){
            node.infinitieLoop->accept(*this);
        }else{
            if(node.condition){
                node.condition->accept(*this);
            }
            if(node.PredicateLoopExpression){
                node.PredicateLoopExpression->accept(*this);
            }
        }
    }

    void visit(ExprMethodcall &node) override{
        //todo wait to be fixed
        node.expr->accept(*this);
        node.PathExprSegment->accept(*this);
        if(node.callParams.size() > 0) {
            for(auto &param : node.callParams) {
                param->accept(*this);
            }
        }
    }

    void visit(ExprOpbinary &node) override{
        node.left->accept(*this);
        node.right->accept(*this);
    }

    void visit(ExprOpunary &node) override{
        node.right->accept(*this);
    }

    void visit(ExprPath &node) override{
        node.pathFirst->accept(*this);
        if(node.pathSecond){
            node.pathSecond->accept(*this);
            if(node.pathFirst->pathSegments.type == IDENTIFIER) {
                auto symbol = current_scope->lookupTypeSymbol(node.pathFirst->pathSegments.identifier);
                if(!symbol) {
                    throw std::runtime_error("Type symbol not found: " + node.pathFirst->pathSegments.identifier);
                }
                if(symbol->symbol_type == Enum){
                    auto enumSymbol = std::dynamic_pointer_cast<EnumSymbol>(symbol);
                    for(auto &variant : enumSymbol->variants) {
                        if(variant == node.pathSecond->pathSegments.identifier){
                            return;
                        }
                    }
                    throw std::runtime_error("Enum variant not found: " + node.pathSecond->pathSegments.identifier);
                }else if(symbol->symbol_type == Struct){

                }
            }
        }else{
            if(node.pathFirst->pathSegments.type == IDENTIFIER) {
                auto symbol = current_scope->lookupValueSymbol(node.pathFirst->pathSegments.identifier);
                if(!symbol) {
                    symbol = current_scope->lookupTypeSymbol(node.pathFirst->pathSegments.identifier);
                    if(!symbol) {
                        throw std::runtime_error("Symbol not found: " + node.pathFirst->pathSegments.identifier);
                    }else{
                        node.resolvedSymbol1 = symbol;
                    }
                }else{
                    node.resolvedSymbol1 = symbol; 
                }
            }
        }
    }

    void visit(ExprReturn &node) override{
        if(node.expr){
            node.expr->accept(*this);
        }
    }

    void visit(ExprStruct &node) override{
        node.pathInExpr->accept(*this);
        for(auto &field : node.structExprFields) {
            field.expr->accept(*this);
        }
    }

    void visit(ExprUnderscore &node) override{}

    //Item
    void visit(Item &node) override {
        if(auto *p = dynamic_cast<ItemConstDecl *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ItemEnumDecl *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ItemFnDecl *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ItemImplDecl *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ItemStructDecl *>(& node)) {    
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ItemTraitDecl *>(& node)) {
            p->accept(*this);
        }else{
            std::cerr << "Unknown Item type in NameResolver\n";
        }
    }

    void visit(ItemConstDecl &node) override{
        if(current_scope != global_scope_builder.global_scope){
            std::shared_ptr<ConstSymbol> symbol = std::make_shared<ConstSymbol>();
            symbol->symbol_type = Const;
            symbol->identifier = node.identifier;
            symbol->type = node.type;
            symbol->value = node.expr;
            current_scope->addValueSymbol(node.identifier, symbol);
        }
        if(auto *p = dynamic_cast<Path *>(& *node.type)) {
            std::string id = p->pathSegments.identifier;
            auto symbol = current_scope->lookupTypeSymbol(id);
            if(!symbol) {
                throw std::runtime_error("Value symbol not found: " + id);
            }else{
                p->resolvedSymbol = symbol;
            }
        }
        if(node.expr){
            node.expr->accept(*this);
        }
    }

    void visit(ItemEnumDecl &node) override{
        if(current_scope != global_scope_builder.global_scope){
            std::shared_ptr<EnumSymbol> symbol = std::make_shared<EnumSymbol>();
            symbol->symbol_type = Enum;
            symbol->identifier = node.identifier;
            for (auto &variant : node.item_enum) {
                symbol->variants.push_back(variant);
            }
            current_scope->addTypeSymbol(node.identifier, symbol);
        }
        for(auto &variant : node.item_enum) {
            std::shared_ptr<EnumVariantSymbol> variantSymbol = std::make_shared<EnumVariantSymbol>();
            variantSymbol->symbol_type = EnumVariant;
            variantSymbol->identifier = variant;
            variantSymbol->enum_decl = std::make_shared<ItemEnumDecl>(node);
            current_scope->addValueSymbol(variant, variantSymbol);
        }
    }

    void visit(ItemFnDecl &node) override{
        if(current_scope != global_scope_builder.global_scope){
            std::shared_ptr<FunctionSymbol> symbol = std::make_shared<FunctionSymbol>();
            symbol->symbol_type = Function;
            symbol->identifier = node.identifier;
            if(node.returnType){
                symbol->return_type = node.returnType;
            }else{
                symbol->return_type = std::make_shared<TypeUnit>(TypeUnit());
            }
            if(node.fnParameters.FunctionParam.size() > 0){
                for(auto &param : node.fnParameters.FunctionParam){
                    if(auto *p = dynamic_cast<PatternIdentifier *>(& *param.pattern)){
                        symbol->parameters.push_back({p->identifier,param.type});
                    }else if(auto *p = dynamic_cast<PatternReference *>(& *param.pattern)){
                        if(auto *q = dynamic_cast<PatternIdentifier *>(& *p->patternWithoutRange)){
                            symbol->parameters.push_back({q->identifier,param.type});
                        }else{
                            std::cerr << "Unsupported pattern in function parameter in NameResolver\n";
                        }
                    }
                }
            }
            current_scope->addValueSymbol(node.identifier, symbol);
        }
        auto fn_scope = std::make_shared<ScopeNode>();
        fn_scope->parent = current_scope;
        fn_scope->ast_node = std::make_shared<ItemFnDecl>(node);
        current_scope = fn_scope;
        for(auto &param: node.fnParameters.FunctionParam){
            std::shared_ptr<VariableSymbol> varSymbol = std::make_shared<VariableSymbol>();
            varSymbol->symbol_type = Variable;
            if(auto *p = dynamic_cast<PatternIdentifier *>(& *param.pattern)){
                varSymbol->identifier = p->identifier;
                varSymbol->type = param.type;
                current_scope->addValueSymbol(p->identifier, varSymbol);
            }else if(auto *p = dynamic_cast<PatternReference *>(& *param.pattern)){
                if(auto *q = dynamic_cast<PatternIdentifier *>(& *p->patternWithoutRange)){
                    varSymbol->identifier = q->identifier;
                    varSymbol->type = param.type;
                    current_scope->addValueSymbol(q->identifier, varSymbol);
                }
            }
            if(auto *p = dynamic_cast<Path *>(& *param.type)){
                std::string id = p->pathSegments.identifier;
                auto symbol = current_scope->lookupTypeSymbol(id);
                if(!symbol) {
                    throw std::runtime_error("Value symbol not found: " + id);
                }else{
                    p->resolvedSymbol = symbol;
                }
            }
        }
        if(node.returnType){
            if(auto *p = dynamic_cast<Path *>(& *node.returnType)){
                std::string id = p->pathSegments.identifier;
                auto symbol = current_scope->lookupTypeSymbol(id);
                if(!symbol) {
                    throw std::runtime_error("Value symbol not found: " + id);
                }else{
                    p->resolvedSymbol = symbol;
                }
            }
        }
        if(node.fnBody){
            node.fnBody->accept(*this);
        }
        current_scope = current_scope->parent;
    }

    void visit(ItemImplDecl &node) override{
        if(node.identifier != ""){
            auto symbolTYPE = current_scope->lookupTypeSymbol(node.identifier);
            if(!symbolTYPE) {
                throw std::runtime_error("Type symbol not found: " + node.identifier);
            }
            if(symbolTYPE->symbol_type != Trait) {
                throw std::runtime_error("Type symbol is not a trait: " + node.identifier);
            }
            if(auto *p = dynamic_cast<Path *>(& *node.targetType)){
                std::string id = p->pathSegments.identifier;
                auto symbolTYPE = current_scope->lookupTypeSymbol(id);
                if(!symbolTYPE) {
                    throw std::runtime_error("Type symbol not found: " + id);
                }else{
                    p->resolvedSymbol = symbolTYPE;
                }
            }
            for(auto &const_item : node.item_trait_const) {
                const_item->accept(*this);
            }
            if(node.item_trait_fn.size() != std::dynamic_pointer_cast<TraitSymbol>(symbolTYPE)->methods.size()) {
                throw std::runtime_error("Impl does not implement all functions of the trait: " + node.identifier);
            }
            for(auto &fn_item : node.item_trait_fn) {
                fn_item->accept(*this); 
            }
        }else{
            if(auto *p = dynamic_cast<Path *>(& *node.targetType)){
                std::string id = p->pathSegments.identifier;
                auto symbolTYPE = current_scope->lookupTypeSymbol(id);
                if(!symbolTYPE) {
                    throw std::runtime_error("Type symbol not found: " + id);
                }else{
                    p->resolvedSymbol = symbolTYPE;
                }
            }
            for(auto &const_item : node.item_trait_const) {
                const_item->accept(*this);  
            }
            for(auto &fn_item : node.item_trait_fn) {
                fn_item->accept(*this); 
            }
        }
    }

    void visit(ItemStructDecl &node) override{
        if(current_scope != global_scope_builder.global_scope){
            std::shared_ptr<StructSymbol> symbol = std::make_shared<StructSymbol>();
            symbol->symbol_type = Struct;
            symbol->identifier = node.identifier;
            for(auto &struct_field: node.item_struct) {
                symbol->fields.push_back({struct_field.identifier, struct_field.structElem});
            }
            current_scope->addTypeSymbol(node.identifier, symbol);
        }
        //current_scope->addTypeSymbol(node.identifier, std::make_shared<Symbol>(std::make_shared<ItemStructDecl>(node), Struct, node.identifier));
        for(auto &struct_field: node.item_struct) {
            if(auto *p = dynamic_cast<Path *>(& *struct_field.structElem)){
                std::string id = p->pathSegments.identifier;
                auto symbol = current_scope->lookupTypeSymbol(id);
                if(!symbol) {
                    throw std::runtime_error("Value symbol not found: " + id);
                }else{
                    p->resolvedSymbol = symbol;
                }
            }
        }
    }

    void visit(ItemTraitDecl &node) override{
        if(current_scope != global_scope_builder.global_scope){
            std::shared_ptr<TraitSymbol> symbol = std::make_shared<TraitSymbol>();
            symbol->symbol_type = Trait;
            symbol->identifier = node.identifier;
            current_scope->addTypeSymbol(node.identifier, symbol);
        }
        //current_scope->addTypeSymbol(node.identifier, std::make_shared<Symbol>(std::make_shared<ItemTraitDecl>(node), Trait, node.identifier));
        for(auto &const_item : node.item_trait_const) {
            const_item->accept(*this);  
        }
        for(auto &fn_item : node.item_trait_fn) {
            fn_item->accept(*this); 
        }
    }

    //Pattern
    void visit(Pattern &node) override {
        if(auto *p = dynamic_cast<PatternIdentifier *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<PatternLiteral *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<PatternPath *>(& node)) {
            p->accept(*this);     
        }else if(auto *p = dynamic_cast<PatternReference *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<PatternWildCard *>(& node)) {   
            p->accept(*this);
        }else if(auto *p = dynamic_cast<PatternTupleStruct *>(& node)) {
            p->accept(*this);
        }else{
            std::cout << "Unknown Pattern type in PrintVisitor\n";
        }
    }

    void visit(PatternIdentifier &node) override{}

    void visit(PatternLiteral &node) override{}

    void visit(PatternPath &node) override{}

    void visit(PatternReference &node) override{}

    void visit(PatternWildCard &node) override{}

    //Statement
    void visit(Statement &node) override {
        if(auto *p = dynamic_cast<StmtEmpty *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<StmtExpr *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<StmtItem *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<StmtLet *>(& node)) {
            p->accept(*this);
        }else{
            std::cout << "Unknown Statement type in PrintVisitor\n";
        }
    }

    void visit(StmtEmpty &node) override{}

    void visit(StmtExpr &node) override{
        node.stmtExpr->accept(*this);
    }

    void visit(StmtItem &node) override{
        node.stmt_item->accept(*this);
    }

    void visit(StmtLet &node) override{
        if(auto *p = dynamic_cast<PatternIdentifier *>(& *node.PatternNoTopAlt)){
            std::shared_ptr<VariableSymbol> symbol = std::make_shared<VariableSymbol>();
            symbol->symbol_type = Variable;
            symbol->identifier = p->identifier;
            symbol->type = node.type;
            current_scope->addValueSymbol(p->identifier, symbol);
        }else if(auto *p = dynamic_cast<PatternReference *>(& *node.PatternNoTopAlt)){
            if(auto *q = dynamic_cast<PatternIdentifier *>(& *p->patternWithoutRange)){
                std::shared_ptr<VariableSymbol> symbol = std::make_shared<VariableSymbol>();
                symbol->symbol_type = Variable;
                symbol->identifier = q->identifier;
                symbol->type = node.type;
                current_scope->addValueSymbol(q->identifier,symbol );
            }
        }
        if(auto *p = dynamic_cast<Path *>(& *node.type)){
            std::string id = p->pathSegments.identifier;
            auto symbol = current_scope->lookupTypeSymbol(id);
            if(!symbol) {
                throw std::runtime_error("Value symbol not found: " + id);
            }else{
                p->resolvedSymbol = symbol;
            }
        }
        node.expression->accept(*this);
    }


    //Type
    void visit(Type &node) override {}

    void visit(TypeArray &node) override{}
    
    void visit(TypePath &node) override{}

    void visit(TypeReference &node) override{}

    void visit(TypeUnit &node) override{}

    //Path
    void visit(Path &node) override{}
};
}