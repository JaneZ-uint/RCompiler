# pragma once

#include "../ast/astvisitor.h"
#include "../ast/Expression/ExprConstBlock.h"
#include "../ast/Expression/ExprStruct.h"
#include "../ast/Expression/expression.h"
#include "../ast/root.h"
#include "../ast/Expression/ExprArray.h"
#include "../ast/Expression/ExprBlock.h"
#include "../ast/Expression/ExprBreak.h"
#include "../ast/Expression/ExprCall.h"
#include "../ast/Expression/ExprContinue.h"
#include "../ast/Expression/ExprField.h"
#include "../ast/Expression/ExprGroup.h"
#include "../ast/Expression/ExprIf.h"
#include "../ast/Expression/ExprIndex.h"
#include "../ast/Expression/ExprLiteral.h"
#include "../ast/Expression/ExprLoop.h"
#include "../ast/Expression/ExprMatch.h"
#include "../ast/Expression/ExprMethodcall.h"
#include "../ast/Expression/ExprOpbinary.h"
#include "../ast/Expression/ExprOpunary.h"
#include "../ast/Expression/ExprPath.h"
#include "../ast/Expression/ExprReturn.h"
#include "../ast/Expression/ExprUnderscore.h"
#include "../ast/Item/ItemConst.h"
#include "../ast/Item/ItemEnum.h"
#include "../ast/Item/ItemFn.h"
#include "../ast/Item/ItemImpl.h"
#include "../ast/Item/ItemStruct.h"
#include "../ast/Item/ItemTrait.h"
#include "../ast/Pattern/PatternIdentifier.h"
#include "../ast/Pattern/PatternLiteral.h"
#include "../ast/Pattern/PatternPath.h"
#include "../ast/Pattern/PatternReference.h"
#include "../ast/Pattern/PatternTupleStruct.h"
#include "../ast/Pattern/PatternWildcard.h"
#include "../ast/Statement/StmtEmpty.h"
#include "../ast/Statement/StmtExpr.h"
#include "../ast/Statement/StmtItem.h"
#include "../ast/Statement/StmtLet.h"
#include "../ast/Type/type.h"
#include "../ast/Type/TypeArray.h"
#include "../ast/Type/TypePath.h"
#include "../ast/Type/TypeReference.h"
#include "../ast/Type/TypeUnit.h"
#include "globalScope.h"
#include "scope.h"
#include "symbol.h"
#include <iostream>
#include <memory>
#include <stdexcept>

// part generated by github copilot.
namespace JaneZ {
class NameResolver : public ASTVisitor{
public:
    std::shared_ptr<ScopeNode> current_scope;

    GlobalScopeBuilder global_scope_builder;

    NameResolver() = default;

    ~NameResolver() = default;
    
    //Start: generated by github copilot.
    void visit(ASTNode &node) override {
        if(auto *p = dynamic_cast<ASTRootNode *>(& node)) {
            node.accept(*this);
        }else if(auto *p = dynamic_cast<Expression *>(& node)) {
            node.accept(*this);
        }else if(auto *p = dynamic_cast<Item *>(& node)) {
            node.accept(*this);
        }else if(auto *p = dynamic_cast<Pattern *>(& node)) {
            node.accept(*this);
        }else if(auto *p = dynamic_cast<Statement *>(& node)) {
            node.accept(*this);
        }else if(auto *p = dynamic_cast<Type *>(& node)) {
            node.accept(*this);
        }else if(auto *p = dynamic_cast<TypeArray *>(& node)) {
            node.accept(*this);
        }else if(auto *p = dynamic_cast<TypePath *>(& node)) {
            node.accept(*this);
        }else if(auto *p = dynamic_cast<TypeReference *>(& node)) {
            node.accept(*this);
        }else if(auto *p = dynamic_cast<TypeUnit *>(& node)) {
            node.accept(*this);
        }else{
            std::cout << "Unknown node type in PrintVisitor\n";
        }
    }
    //End: generated by github copilot.

    void visit(ASTRootNode &node) override {
        current_scope = global_scope_builder.global_scope;
        for(auto &item : node.child) {
            //item->accept(*this);
            visit(*item);
        }
    }

    //Expression
    void visit(Expression &node) override {
        if(auto *p = dynamic_cast<ExprArray *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprBlock *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprBreak *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprCall *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprConstBlock *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprContinue *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprField *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprGroup *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprIf *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprIndex *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprLiteral *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprLoop *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprMatch *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprMethodcall *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprOpbinary *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprOpunary *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprPath *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprReturn *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprStruct *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ExprUnderscore *>(& node)) {
            p->accept(*this);
        }else{
            std::cout << "Unknown Expression type in PrintVisitor\n";
        }
    }

    void visit(ExprArray &node) override{
        if(node.arrayExpr.size() > 0) {
            for(auto &expr : node.arrayExpr) {
                expr->accept(*this);
            }
            bool isBool = false;
            bool isI32 = false;
            bool isU32 = false;
            bool isISize = false;
            bool isUSize = false;
            bool isString = false;
            bool isEnum = false;
            bool isStruct = false;
            if(auto *p = dynamic_cast<ExprLiteral *>(& *node.arrayExpr[0])){
                if(p->type == TRUE || p->type == FALSE){
                    isBool = true;
                }else if(p->type == INTEGER_LITERAL){
                    isI32 = true;
                    isU32 = true;
                    isISize = true;
                    isUSize = true;
                }else if(p->type == STRING_LITERAL){
                    isString = true;
                }
            }else if(auto *p = dynamic_cast<ExprPath *>(& *node.arrayExpr[0])){
                if(p->pathSecond == nullptr){
                    if(p->pathFirst->pathSegments.type == IDENTIFIER) {
                        auto symbol = current_scope->lookupValueSymbol(p->pathFirst->pathSegments.identifier);
                        if(!symbol) {
                            throw std::runtime_error("Value symbol not found: " + p->pathFirst->pathSegments.identifier);
                        }
                        if(symbol->symbol_type == Variable){
                            auto varSymbol = std::dynamic_pointer_cast<VariableSymbol>(symbol);
                            if(auto *q = dynamic_cast<Type *>(& *varSymbol->type)){
                                if(q->type == BOOL){
                                    isBool = true;
                                }else if(q->type == I32 ){
                                    isI32 = true;   
                                }else if(q->type == U32 ){
                                    isU32 = true;
                                }else if(q->type == ISIZE ){
                                    isISize = true; 
                                }else if(q->type == USIZE ){
                                    isUSize = true;
                                }else if(q->type == STR){
                                    isString = true;
                                }
                            }else if(auto *q = dynamic_cast<Path *>(& *varSymbol->type)){
                                if(q->pathSegments.type == IDENTIFIER){
                                    auto typeSymbol = current_scope->lookupTypeSymbol(q->pathSegments.identifier);
                                    if(!typeSymbol) {
                                        throw std::runtime_error("Type symbol not found: " + q->pathSegments.identifier);
                                    }
                                    if(typeSymbol->symbol_type == Struct){
                                        isStruct = true;
                                    }
                                }
                            }
                        }else if(symbol->symbol_type == Const){
                            auto constSymbol = std::dynamic_pointer_cast<ConstSymbol>(symbol);
                            if(auto *q = dynamic_cast<Type *>(& *constSymbol->type)){
                                if(q->type == BOOL){
                                    isBool = true;  
                                }else if(q->type == I32 ){
                                    isI32 = true;   
                                }else if(q->type == U32 ){
                                    isU32 = true;
                                }else if(q->type == ISIZE ){
                                    isISize = true; 
                                }else if(q->type == USIZE ){
                                    isUSize = true;
                                }else if(q->type == STR){
                                    isString = true;
                                }
                            }
                        }
                    }
                }else{
                    if(p->pathFirst->pathSegments.type == IDENTIFIER) {
                        auto symbol = current_scope->lookupTypeSymbol(p->pathFirst->pathSegments.identifier);
                        if(!symbol) {
                            throw std::runtime_error("Type symbol not found: " + p->pathFirst->pathSegments.identifier);
                        }
                        if(symbol->symbol_type == Enum){
                            isEnum = true;
                        }else if(symbol->symbol_type == Struct){
                            isStruct = true;    
                        }
                    }
                }
            }
            if(isBool || isEnum || isI32 || isU32 || isISize || isUSize || isString || isStruct){
                for(int i = 1;i < node.arrayExpr.size();i ++){
                    auto &expr = node.arrayExpr[i];
                    if(isEnum || isStruct){
                        if(auto *p = dynamic_cast<ExprLiteral *>(& *expr)){
                            throw std::runtime_error("Array element type mismatch, expected enum or struct");
                        }else if(auto *p = dynamic_cast<ExprPath *>(& *expr)){ 
                            auto symbol = current_scope->lookupValueSymbol(p->pathFirst->pathSegments.identifier);
                            if(!symbol) {
                                throw std::runtime_error("Value symbol not found: " + p->pathFirst->pathSegments.identifier);
                            }
                            if(symbol->symbol_type == Variable){
                                auto varSymbol = std::dynamic_pointer_cast<VariableSymbol>(symbol);
                                if(auto *q = dynamic_cast<Type *>(& *varSymbol->type)){
                                    throw std::runtime_error("Array element type mismatch, expected enum or struct");
                                }
                            }
                        }
                    }
                }
            }
        }else{
            node.type->accept(*this);
            node.size->accept(*this);
            if(auto *p = dynamic_cast<ExprPath *>(& *node.size)){
                if(p->pathSecond == nullptr){
                    if(p->pathFirst->pathSegments.type == IDENTIFIER) {
                        auto symbol = current_scope->lookupValueSymbol(p->pathFirst->pathSegments.identifier);
                        if(!symbol) {
                            throw std::runtime_error("Value symbol not found: " + p->pathFirst->pathSegments.identifier);
                        }
                        if(symbol->symbol_type != Const) {
                            throw std::runtime_error("Value symbol is not a const: " + p->pathFirst->pathSegments.identifier);
                        }
                        p->resolvedSymbol1 = symbol;
                    }
                }
            }
        }
    }

    void visit(ExprBlock &node) override{
        /*if(node.statements.size() > 0){
            for(auto &stmt : node.statements) {
                stmt->accept(*this);
            }
        }
        if(node.ExpressionWithoutBlock){
            node.ExpressionWithoutBlock->accept(*this);
        }*/
        auto block_scope = std::make_shared<ScopeNode>();
        block_scope->parent = current_scope;
        current_scope = block_scope;
        if(node.statements.size() > 0){
            for(auto &stmt : node.statements) {
                stmt->accept(*this);
            }
        }
        if(node.ExpressionWithoutBlock){
            node.ExpressionWithoutBlock->accept(*this);
        }
        //std::shared_ptr<Symbol> printInInt = 
    }

    void visit(ExprBreak &node) override{}

    void visit(ExprCall &node) override{
        //todo may check function param type
        if(auto *p = dynamic_cast<ExprPath *>(& *node.expr)) {
            if(p->pathSecond){
                if(p->pathFirst->pathSegments.type == IDENTIFIER && p->pathFirst->pathSegments.identifier != "String") {
                    auto symbol = current_scope->lookupTypeSymbol(p->pathFirst->pathSegments.identifier);
                    if(!symbol) {
                        throw std::runtime_error("Type symbol not found: " + p->pathFirst->pathSegments.identifier);
                    }else{
                        p->resolvedSymbol1 = symbol; 
                    }
                    if(symbol->symbol_type == Struct){
                        auto structSymbol = std::dynamic_pointer_cast<StructSymbol>(symbol);
                        if(structSymbol->methods.find(p->pathSecond->pathSegments.identifier) == structSymbol->methods.end()){
                            throw std::runtime_error("Method not found in struct: " + p->pathSecond->pathSegments.identifier);
                        }
                    }else if(symbol->symbol_type == Trait){
                        auto traitSymbol = std::dynamic_pointer_cast<TraitSymbol>(symbol);
                        if(traitSymbol->methods.find(p->pathSecond->pathSegments.identifier) == traitSymbol->methods.end()){
                            throw std::runtime_error("Method not found in trait: " + p->pathSecond->pathSegments.identifier);
                        }
                    }else{
                        throw std::runtime_error("Type is not a struct or trait: " + p->pathFirst->pathSegments.identifier);
                    }
                }
            }else{
                auto symbol = current_scope->lookupValueSymbol(p->pathFirst->pathSegments.identifier);
                if(symbol->symbol_type == Function){
                    p->resolvedSymbol1 = symbol;
                }else{
                    throw std::runtime_error("Value symbol is not a function: " + p->pathFirst->pathSegments.identifier);
                }
                if(p->pathFirst->pathSegments.identifier == "exit"){
                    auto param = node.callParams[0];
                    if(auto *q = dynamic_cast<ExprPath *>(& *param)){
                        if(q->pathSecond == nullptr){
                            if(q->pathFirst->pathSegments.type == IDENTIFIER) {
                                auto symbol = current_scope->lookupValueSymbol(q->pathFirst->pathSegments.identifier);
                                if(!symbol) {
                                    throw std::runtime_error("Value symbol not found: " + q->pathFirst->pathSegments.identifier);
                                }
                                if(symbol->symbol_type == Variable){
                                    auto varSymbol = std::dynamic_pointer_cast<VariableSymbol>(symbol);
                                    if(auto *r = dynamic_cast<Type *>(& *varSymbol->type)){
                                        if(r->type != I32 && r->type != U32 && r->type != ISIZE && r->type != USIZE){
                                            throw std::runtime_error("exit function parameter must be integer type");
                                        }
                                    }
                                }
                                
                            }
                        }
                    }
                }
            }
        }
        if(node.callParams.size() > 0) {
            for(auto &param : node.callParams) {
                param->accept(*this);
            }
        }

        //check callParams type
        if(auto *p = dynamic_cast<ExprPath *>(& *node.expr)){
            if(p->pathSecond == nullptr){
                if(p->pathFirst->pathSegments.type == IDENTIFIER){
                    if(p->pathFirst->pathSegments.identifier != "exit" && p->pathFirst->pathSegments.identifier != "printInt" && p->pathFirst->pathSegments.identifier != "getInt" && p->pathFirst->pathSegments.identifier != "printlnInt"){
                        auto symbol = current_scope->lookupValueSymbol(p->pathFirst->pathSegments.identifier);
                        if(!symbol) {
                            throw std::runtime_error("Value symbol not found: " + p->pathFirst->pathSegments.identifier);
                        }
                        if(symbol->symbol_type != Function){
                            throw std::runtime_error("Value symbol is not a function: " + p->pathFirst->pathSegments.identifier);
                        }
                        auto funcSymbol = std::dynamic_pointer_cast<FunctionSymbol>(symbol);
                        if(funcSymbol->parameters.size() != node.callParams.size()){
                            throw std::runtime_error("Function call parameter count mismatch: " + p->pathFirst->pathSegments.identifier);
                        }
                        for(int i = 0;i < funcSymbol->parameters.size();i ++){
                            auto funParam = funcSymbol->parameters[i];
                            auto callParam = node.callParams[i];
                            if(auto *q = dynamic_cast<ExprLiteral *>(& *callParam)){
                                if(auto *r = dynamic_cast<Type *>(& *funParam.type)){
                                    if(r->type == I32 || r->type == U32 || r->type == ISIZE || r->type == USIZE ){
                                        if(q->type != INTEGER_LITERAL){
                                            throw std::runtime_error("Function call parameter type mismatch: " + p->pathFirst->pathSegments.identifier);
                                        }else if(r->type == I32){
                                            if(q->integer < -2147483648 || q->integer > 2147483647){
                                                throw std::runtime_error("Function call parameter out of range: " + p->pathFirst->pathSegments.identifier);
                                            }
                                        }
                                    }else if(r->type == STR){
                                        if(q->type != STRING_LITERAL){
                                            throw std::runtime_error("Function call parameter type mismatch: " + p->pathFirst->pathSegments.identifier);
                                        }
                                    }
                                }else if(auto *r = dynamic_cast<Path *>(& *funParam.type)){
                                    throw std::runtime_error("Function call parameter type mismatch: " + p->pathFirst->pathSegments.identifier);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    void visit(ExprConstBlock &node) override{
        node.expr->accept(*this);
    }

    void visit(ExprContinue &node) override{}

    void visit(ExprField &node) override{
        if(auto *p = dynamic_cast<ExprPath *>(& *node.expr)){
            if(p->pathFirst->pathSegments.type == IDENTIFIER) {
                auto symbol = current_scope->lookupValueSymbol(p->pathFirst->pathSegments.identifier);
                if(!symbol) {
                    throw std::runtime_error("Value symbol not found: " + p->pathFirst->pathSegments.identifier);
                }
                if(symbol->symbol_type != Variable) {
                    throw std::runtime_error("Value symbol is not a variable: " + p->pathFirst->pathSegments.identifier);
                }
                auto varSymbol = std::dynamic_pointer_cast<VariableSymbol>(symbol);
                if(auto *q = dynamic_cast<Path *>(& *varSymbol->type)) {
                    if(q->pathSegments.type == IDENTIFIER){
                        auto typeSymbol = current_scope->lookupTypeSymbol(q->pathSegments.identifier);
                        if(!typeSymbol) {
                            throw std::runtime_error("Type symbol not found: " + q->pathSegments.identifier);
                        }
                        if(typeSymbol->symbol_type != Struct) {
                            throw std::runtime_error("Type symbol is not a struct: " + q->pathSegments.identifier);
                        }
                        auto structSymbol = std::dynamic_pointer_cast<StructSymbol>(typeSymbol);
                        bool field_found = false;
                        for(auto &field : structSymbol->fields) {
                            if(field.name == node.identifier) {
                                field_found = true;
                                break;
                            }
                        }
                        if(!field_found) {
                            throw std::runtime_error("Field not found in struct: " + node.identifier);
                        }
                        p->resolvedSymbol1 = typeSymbol;
                        p->resolvedSymbol2 = symbol;
                    }
                }
            }
        }
    }

    void visit(ExprGroup &node) override{
        node.expr->accept(*this);
    }

    void visit(ExprIf &node) override{
        node.condition->accept(*this);
        std::shared_ptr<ScopeNode> if_scope = std::make_shared<ScopeNode>();
        if_scope->parent = current_scope;
        current_scope = if_scope;
        std::string then_type = "";
        if(node.thenBlock){
            for(auto &stmt : node.thenBlock->statements) {
                stmt->accept(*this);
            }
            if(node.thenBlock->ExpressionWithoutBlock){
                node.thenBlock->ExpressionWithoutBlock->accept(*this);
                if(auto *p = dynamic_cast<ExprLiteral *>(& *node.thenBlock->ExpressionWithoutBlock)){
                    if(p->type == INTEGER_LITERAL){
                        then_type = "int";
                    }else if(p->type == STRING_LITERAL){
                        then_type = "string";
                    }else if(p->type == TRUE || p->type == FALSE){
                        then_type = "bool";
                    }
                }else if(auto *p = dynamic_cast<ExprPath *>(& *node.thenBlock->ExpressionWithoutBlock)){
                    if(p->pathSecond == nullptr){
                        if(p->pathFirst->pathSegments.type == IDENTIFIER) {
                            auto symbol = current_scope->lookupValueSymbol(p->pathFirst->pathSegments.identifier);
                            if(!symbol) {
                                throw std::runtime_error("Value symbol not found: " + p->pathFirst->pathSegments.identifier);
                            }
                            if(symbol->symbol_type == Variable){
                                auto varSymbol = std::dynamic_pointer_cast<VariableSymbol>(symbol);
                                if(auto *q = dynamic_cast<Type *>(& *varSymbol->type)){
                                    if(q->type == I32 || q->type == U32 || q->type == ISIZE || q->type == USIZE){
                                        then_type = "int";
                                    }else if(q->type == BOOL){
                                        then_type = "bool";
                                    }else if(q->type == STR){
                                        then_type = "string";
                                    }
                                }
                            }else if(symbol->symbol_type == Const){
                                auto constSymbol = std::dynamic_pointer_cast<ConstSymbol>(symbol);
                                if(auto *q = dynamic_cast<Type *>(& *constSymbol->type)){
                                    if(q->type == I32 || q->type == U32 || q->type == ISIZE || q->type == USIZE){
                                        then_type = "int";
                                    }else if(q->type == BOOL){
                                        then_type = "bool";
                                    }else if(q->type == STR){
                                        then_type = "string";
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        current_scope = current_scope->parent;
        if(node.elseBlock){
            if(auto *p = dynamic_cast<ExprBlock *>(& *node.elseBlock)){
                std::shared_ptr<ScopeNode> else_scope = std::make_shared<ScopeNode>();
                else_scope->parent = current_scope;
                current_scope = else_scope;
                for(auto &stmt : p->statements) {
                    stmt->accept(*this);
                }
                if(p->ExpressionWithoutBlock){
                    p->ExpressionWithoutBlock->accept(*this);
                    if(auto *q = dynamic_cast<ExprLiteral *>(& *p->ExpressionWithoutBlock)){
                        if(q->type == INTEGER_LITERAL){
                            if(then_type != "int" && then_type != ""){
                                throw std::runtime_error("If-else expression type mismatch");
                            }
                        }else if(q->type == STRING_LITERAL){
                            if(then_type != "string" && then_type != ""){
                                throw std::runtime_error("If-else expression type mismatch");
                            }
                        }else if(q->type == TRUE || q->type == FALSE){
                            if(then_type != "bool" && then_type != ""){
                                throw std::runtime_error("If-else expression type mismatch");
                            }
                        }
                    }else if(auto *q = dynamic_cast<ExprPath *>(& *p->ExpressionWithoutBlock)){
                        if(q->pathSecond == nullptr){
                            if(q->pathFirst->pathSegments.type == IDENTIFIER) {
                                auto symbol = current_scope->lookupValueSymbol(q->pathFirst->pathSegments.identifier);
                                if(!symbol) {
                                    throw std::runtime_error("Value symbol not found: " + q->pathFirst->pathSegments.identifier);
                                }
                                if(symbol->symbol_type == Variable){
                                    auto varSymbol = std::dynamic_pointer_cast<VariableSymbol>(symbol);
                                    if(auto *r = dynamic_cast<Type *>(& *varSymbol->type)){
                                        if(r->type == I32 || r->type == U32 || r->type == ISIZE || r->type == USIZE){
                                            if(then_type != "int" && then_type != ""){
                                                throw std::runtime_error("If-else expression type mismatch");
                                            }
                                        }else if(r->type == BOOL){
                                            if(then_type != "bool" && then_type != ""){
                                                throw std::runtime_error("If-else expression type mismatch");
                                            }
                                        }else if(r->type == STR){
                                            if(then_type != "string" && then_type != ""){
                                                throw std::runtime_error("If-else expression type mismatch");
                                            }
                                        }
                                    }
                                }else if(symbol->symbol_type == Const){
                                    auto constSymbol = std::dynamic_pointer_cast<ConstSymbol>(symbol);
                                    if(auto *r = dynamic_cast<Type *>(& *constSymbol->type)){
                                        if(r->type == I32 || r->type == U32 || r->type == ISIZE || r->type == USIZE){
                                            if(then_type != "int" && then_type != ""){
                                                throw std::runtime_error("If-else expression type mismatch");
                                            }
                                        }else if(r->type == BOOL){
                                            if(then_type != "bool" && then_type != ""){
                                                throw std::runtime_error("If-else expression type mismatch");
                                            }
                                        }else if(r->type == STR){
                                            if(then_type != "string" && then_type != ""){
                                                throw std::runtime_error("If-else expression type mismatch");
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                current_scope = current_scope->parent;
            }else if(auto *p = dynamic_cast<ExprIf *>(& *node.elseBlock)){
                node.elseBlock->accept(*this);
            }
        }
    }

    void visit(ExprIndex &node) override{
        node.name->accept(*this);
        node.index->accept(*this);
        //todo check if index is integer type
        if(auto *p = dynamic_cast<ExprPath *>(& *node.index)){
            if(p->pathSecond == nullptr){
                if(p->pathFirst->pathSegments.type == IDENTIFIER){
                    auto symbol = current_scope->lookupValueSymbol(p->pathFirst->pathSegments.identifier);
                    if(!symbol) {
                        throw std::runtime_error("Value symbol not found: " + p->pathFirst->pathSegments.identifier);
                    }
                    if(symbol->symbol_type == Variable){
                        auto varSymbol = std::dynamic_pointer_cast<VariableSymbol>(symbol);
                        if(auto *q = dynamic_cast<Type *>(& *varSymbol->type)){
                            if(q->type != I32 && q->type != U32 && q->type != ISIZE && q->type != USIZE){
                                throw std::runtime_error("Array index must be integer type");
                            }
                        }
                    }
                }
            }
        }
    }

    void visit(ExprLiteral &node) override{}

    void visit(ExprLoop &node) override{
        if(node.infinitieLoop){
            std::shared_ptr<ScopeNode> loop_scope = std::make_shared<ScopeNode>();
            loop_scope->parent = current_scope;
            current_scope = loop_scope;
            for(auto &stmt : node.infinitieLoop->statements) {
                stmt->accept(*this);
            }
            if(node.infinitieLoop->ExpressionWithoutBlock){
                node.infinitieLoop->ExpressionWithoutBlock->accept(*this);
            }
            current_scope = current_scope->parent;
        }else{
            if(node.condition){
                node.condition->accept(*this);
            }
            std::shared_ptr<ScopeNode> loop_scope = std::make_shared<ScopeNode>();
            loop_scope->parent = current_scope;
            current_scope = loop_scope;
            if(node.PredicateLoopExpression){
                for(auto &stmt : node.PredicateLoopExpression->statements) {
                    stmt->accept(*this);
                }
                if(node.PredicateLoopExpression->ExpressionWithoutBlock){
                    node.PredicateLoopExpression->ExpressionWithoutBlock->accept(*this);
                }
            }
            current_scope = current_scope->parent;
        }
    }

    void visit(ExprMethodcall &node) override{
        //node.expr->accept(*this);
        if(auto *p = dynamic_cast<ExprPath *>(& *node.expr)){
            if(p->pathSecond == nullptr){
                if(p->pathFirst->pathSegments.type == IDENTIFIER){
                    auto symbolVar = current_scope->lookupValueSymbol(p->pathFirst->pathSegments.identifier);
                    if(!symbolVar) {
                        throw std::runtime_error("Value symbol not found: " + p->pathFirst->pathSegments.identifier);
                    }
                    if(symbolVar->symbol_type != Variable) {
                        throw std::runtime_error("Value symbol is not a variable: " + p->pathFirst->pathSegments.identifier);
                    }
                    auto varSymbol = std::dynamic_pointer_cast<VariableSymbol>(symbolVar);
                    if(auto *q = dynamic_cast<Path *>(& *varSymbol->type)) {
                        if(q->pathSegments.type == IDENTIFIER){
                            auto typeSymbol = current_scope->lookupTypeSymbol(q->pathSegments.identifier);
                            if(!typeSymbol) {
                                throw std::runtime_error("Type symbol not found: " + q->pathSegments.identifier);
                            }
                            if(typeSymbol->symbol_type != Struct && typeSymbol->symbol_type != Trait) {
                                throw std::runtime_error("Type symbol is not a struct or trait: " + q->pathSegments.identifier);
                            }
                            if(typeSymbol->symbol_type == Struct){  
                                auto structSymbol = std::dynamic_pointer_cast<StructSymbol>(typeSymbol);
                                if(structSymbol->methods.find(node.PathExprSegment->pathSegments.identifier) == structSymbol->methods.end()){
                                    throw std::runtime_error("Method not found in struct: " + node.PathExprSegment->pathSegments.identifier);
                                }
                                auto methodSymbol = structSymbol->methods[node.PathExprSegment->pathSegments.identifier];
                                if(methodSymbol->is_mut &&methodSymbol->is_ref){
                                    if(!varSymbol->is_mut){
                                        throw std::runtime_error("Cannot call mutable method on immutable reference");
                                    }
                                }
                            }else if (typeSymbol->symbol_type == Trait){
                                auto traitSymbol = std::dynamic_pointer_cast<TraitSymbol>(typeSymbol);
                                if(traitSymbol->methods.find(node.PathExprSegment->pathSegments.identifier) == traitSymbol->methods.end()){
                                    throw std::runtime_error("Method not found in trait: " + node.PathExprSegment->pathSegments.identifier);
                                }
                            }else{
                                throw std::runtime_error("Type is not a struct or trait: " + q->pathSegments.identifier);
                            }
                        }
                    }else if(auto *q = dynamic_cast<TypeReference *>(& *varSymbol->type)){
                        if(auto *r = dynamic_cast<Path *>(& *q->typeNoBounds)){
                            if(r->pathSegments.type == IDENTIFIER){
                                auto typeSymbol = current_scope->lookupTypeSymbol(r->pathSegments.identifier);
                                if(!typeSymbol) {
                                    throw std::runtime_error("Type symbol not found: " + r->pathSegments.identifier);
                                }
                                if(typeSymbol->symbol_type != Struct && typeSymbol->symbol_type != Trait) {
                                    throw std::runtime_error("Type symbol is not a struct or trait: " + r->pathSegments.identifier);
                                }
                                if(typeSymbol->symbol_type == Struct){  
                                    auto structSymbol = std::dynamic_pointer_cast<StructSymbol>(typeSymbol);
                                    if(structSymbol->methods.find(node.PathExprSegment->pathSegments.identifier) == structSymbol->methods.end()){
                                        throw std::runtime_error("Method not found in struct: " + node.PathExprSegment->pathSegments.identifier);
                                    }
                                    auto methodSymbol = structSymbol->methods[node.PathExprSegment->pathSegments.identifier];
                                    if(methodSymbol->is_mut &&methodSymbol->is_ref){
                                        if(!q->is_mut){
                                            throw std::runtime_error("Cannot call mutable method on immutable reference");
                                        }
                                    }
                                }else if (typeSymbol->symbol_type == Trait){
                                    auto traitSymbol = std::dynamic_pointer_cast<TraitSymbol>(typeSymbol);
                                    if(traitSymbol->methods.find(node.PathExprSegment->pathSegments.identifier) == traitSymbol->methods.end()){
                                        throw std::runtime_error("Method not found in trait: " + node.PathExprSegment->pathSegments.identifier);
                                    }
                                }else{
                                    throw std::runtime_error("Type is not a struct or trait: " + r->pathSegments.identifier);
                                }
                            }
                        }
                    }
                }
            }
        }
        if(node.callParams.size() > 0) {
            for(auto &param : node.callParams) {
                param->accept(*this);
            }
        }
    }

    void visit(ExprOpbinary &node) override{
        if(node.op != AS_CAST){
            node.left->accept(*this);
            node.right->accept(*this);
        }
        //can't assign to immutable variable
        if(node.op == ASSIGN || node.op == PLUS_EQUAL || node.op == MINUS_EQUAL || node.op == MULTIPLY_EQUAL || 
           node.op == DIVIDE_EQUAL || node.op == MODULO_EQUAL || node.op == AND_EQUAL || node.op == OR_EQUAL || 
           node.op == XOR_EQUAL || node.op == LEFT_SHIFT_EQUAL || node.op == RIGHT_SHIFT_EQUAL){
            if(auto *p = dynamic_cast<ExprPath *>(& *node.left)){
                if(p->pathSecond == nullptr){
                    if(p->pathFirst->pathSegments.type == IDENTIFIER) {
                        auto symbol = current_scope->lookupValueSymbol(p->pathFirst->pathSegments.identifier);
                        if(!symbol) {
                            throw std::runtime_error("Value symbol not found: " + p->pathFirst->pathSegments.identifier);
                        }
                        if(symbol->symbol_type != Variable) {
                            throw std::runtime_error("Value symbol is not a variable: " + p->pathFirst->pathSegments.identifier);
                        }
                        auto varSymbol = std::dynamic_pointer_cast<VariableSymbol>(symbol);
                        if(!varSymbol->is_mut){
                            throw std::runtime_error("Cannot assign to immutable variable: " + p->pathFirst->pathSegments.identifier);
                        }
                    }
                }
            }else if(auto *p = dynamic_cast<ExprIndex *>(& *node.left)){
                if(auto *q = dynamic_cast<ExprPath *>(& *p->name)){
                    if(q->pathSecond == nullptr){
                        if(q->pathFirst->pathSegments.type == IDENTIFIER) {
                            auto symbol = current_scope->lookupValueSymbol(q->pathFirst->pathSegments.identifier);
                            if(!symbol) {
                                throw std::runtime_error("Value symbol not found: " + q->pathFirst->pathSegments.identifier);
                            }
                            if(symbol->symbol_type != Variable) {
                                throw std::runtime_error("Value symbol is not a variable: " + q->pathFirst->pathSegments.identifier);
                            }
                            auto varSymbol = std::dynamic_pointer_cast<VariableSymbol>(symbol);
                            if(!varSymbol->is_mut){
                                throw std::runtime_error("Cannot assign to immutable variable: " + q->pathFirst->pathSegments.identifier);
                            }
                        }
                    }
                }else if(auto *q = dynamic_cast<ExprIndex *>(& *p->name)){
                    if(auto *r = dynamic_cast<ExprPath *>(& *q->name)){
                        if(r->pathSecond == nullptr){
                            if(r->pathFirst->pathSegments.type == IDENTIFIER) {
                                auto symbol = current_scope->lookupValueSymbol(r->pathFirst->pathSegments.identifier);
                                if(!symbol) {
                                    throw std::runtime_error("Value symbol not found: " + r->pathFirst->pathSegments.identifier);
                                }
                                if(symbol->symbol_type != Variable) {
                                    throw std::runtime_error("Value symbol is not a variable: " + r->pathFirst->pathSegments.identifier);
                                }
                                auto varSymbol = std::dynamic_pointer_cast<VariableSymbol>(symbol);
                                if(!varSymbol->is_mut){
                                    throw std::runtime_error("Cannot assign to immutable variable: " + r->pathFirst->pathSegments.identifier);
                                }
                            }
                        }
                    }
                }
            }
        }

        //comparision between incompatible types
        if(node.op == EQUAL || node.op == NOT_EQUAL || node.op == LESS_THAN || node.op == LESS_THAN_OR_EQUAL || 
           node.op == GREATER_THAN || node.op == GREATER_THAN_OR_EQUAL){
            //TODO type check
            struct LRtype{
                std::string type_name = "";
                bool is_exprPath = false;
            };
            LRtype ltp;
            if(auto *p = dynamic_cast<ExprPath *>(& *node.left)){
                if(p->pathSecond == nullptr){
                    if(p->pathFirst->pathSegments.type == IDENTIFIER) {
                        ltp.is_exprPath = true;
                        auto symbol = current_scope->lookupValueSymbol(p->pathFirst->pathSegments.identifier);
                        if(!symbol) {
                            throw std::runtime_error("Value symbol not found: " + p->pathFirst->pathSegments.identifier);
                        }
                        if(symbol->symbol_type == Variable){
                            //auto varSymbol = std::
                            if(auto *q = dynamic_cast<Type *>(& *std::dynamic_pointer_cast<VariableSymbol>(symbol)->type)){
                               if(q->type == I32){
                                   ltp.type_name = "i32";
                               }else if (q->type == U32){
                                   ltp.type_name = "u32";
                               }else if (q->type == ISIZE){
                                   ltp.type_name = "isize";
                               }else if(q->type == USIZE){
                                   ltp.type_name = "usize";
                               }else if(q->type == BOOL){
                                   ltp.type_name = "bool";
                               }else if(q->type == CHAR){
                                   ltp.type_name = "char";
                               }else if(q->type == STR){
                                   ltp.type_name = "str";
                               }
                            }else if(auto *q = dynamic_cast<Path *>(& *std::dynamic_pointer_cast<VariableSymbol>(symbol)->type)){
                                if(q->pathSegments.type == IDENTIFIER){
                                    ltp.type_name = q->pathSegments.identifier;
                                }
                            }else if(auto *q = dynamic_cast<TypeReference *>(& *std::dynamic_pointer_cast<VariableSymbol>(symbol)->type)){
                                if(auto *r = dynamic_cast<Type *>(& *q->typeNoBounds)){
                                    if(r->type == I32){
                                        ltp.type_name = "i32";
                                    }else if (r->type == U32){
                                        ltp.type_name = "u32";
                                    }else if (r->type == ISIZE){
                                        ltp.type_name = "isize";
                                    }else if(r->type == USIZE){
                                        ltp.type_name = "usize";
                                    }else if(r->type == BOOL){
                                        ltp.type_name = "bool";
                                    }else if(r->type == CHAR){
                                        ltp.type_name = "char";
                                    }else if(r->type == STR){
                                        ltp.type_name = "str";
                                    }
                                }
                            }
                        }else if(symbol->symbol_type == Const){ 
                            if(auto *q = dynamic_cast<Type *>(& *std::dynamic_pointer_cast<ConstSymbol>(symbol)->type)){
                               if(q->type == I32){
                                   ltp.type_name = "i32";
                               }else if (q->type == U32){
                                   ltp.type_name = "u32";
                               }else if (q->type == ISIZE){
                                   ltp.type_name = "isize";
                               }else if(q->type == USIZE){
                                   ltp.type_name = "usize";
                               }else if(q->type == BOOL){
                                   ltp.type_name = "bool";
                               }else if(q->type == CHAR){
                                   ltp.type_name = "char";
                               }else if(q->type == STR){
                                   ltp.type_name = "str";
                               }
                            }else if(auto *q = dynamic_cast<Path *>(& *std::dynamic_pointer_cast<ConstSymbol>(symbol)->type)){
                                if(q->pathSegments.type == IDENTIFIER){
                                    ltp.type_name = q->pathSegments.identifier;
                                }
                            }
                        }else if(symbol->symbol_type == Function){
                            //todo left with function pointer
                        }
                    }
                }
            }
            LRtype rtp;
            if(auto *p = dynamic_cast<ExprPath *>(& *node.right)){
                if(p->pathSecond == nullptr){
                    if(p->pathFirst->pathSegments.type == IDENTIFIER) { 
                        rtp.is_exprPath = true;
                        auto symbol = current_scope->lookupValueSymbol(p->pathFirst->pathSegments.identifier);
                        if(!symbol) {
                            throw std::runtime_error("Value symbol not found: " + p->pathFirst->pathSegments.identifier);
                        }
                        if(symbol->symbol_type != Variable && symbol->symbol_type != Const) {
                            throw std::runtime_error("Value symbol is not a variable or const: " + p->pathFirst->pathSegments.identifier);
                        }
                        if(symbol->symbol_type == Variable){
                            if(auto *q = dynamic_cast<Type *>(& *std::dynamic_pointer_cast<VariableSymbol>(symbol)->type)){
                               if(q->type == I32){
                                   rtp.type_name = "i32";
                               }else if (q->type == U32){
                                   rtp.type_name = "u32";
                               }else if (q->type == ISIZE){
                                   rtp.type_name = "isize";
                               }else if(q->type == USIZE){
                                   rtp.type_name = "usize";
                               }else if(q->type == BOOL){
                                   rtp.type_name = "bool";
                               }else if(q->type == CHAR){
                                   rtp.type_name = "char";
                               }else if(q->type == STR){
                                   rtp.type_name = "str";
                               }
                            }else if(auto *q = dynamic_cast<Path *>(& *std::dynamic_pointer_cast<VariableSymbol>(symbol)->type)){
                                if(q->pathSegments.type == IDENTIFIER){
                                    rtp.type_name = q->pathSegments.identifier;
                                }
                            }
                        }else if(symbol->symbol_type == Const){ 
                            if(auto *q = dynamic_cast<Type *>(& *std::dynamic_pointer_cast<ConstSymbol>(symbol)->type)){
                               if(q->type == I32){
                                   rtp.type_name = "i32";
                               }else if (q->type == U32){
                                   rtp.type_name = "u32";
                               }else if (q->type == ISIZE){
                                   rtp.type_name = "isize";
                               }else if(q->type == USIZE){
                                   rtp.type_name = "usize";
                               }else if(q->type == BOOL){
                                   rtp.type_name = "bool";
                               }else if(q->type == CHAR){
                                   rtp.type_name = "char";
                               }else if(q->type == STR){
                                   rtp.type_name = "str";
                               }
                            }else if(auto *q = dynamic_cast<Path *>(& *std::dynamic_pointer_cast<ConstSymbol>(symbol)->type)){
                                if(q->pathSegments.type == IDENTIFIER){
                                    rtp.type_name = q->pathSegments.identifier;
                                }
                            }
                        }else if(symbol->symbol_type == Function){
                            //todo left with function pointer
                        }
                    }
                }
            }
            //TODO left with complicated type check
            if(ltp.is_exprPath && rtp.is_exprPath){
                if(ltp.type_name != rtp.type_name){
                    throw std::runtime_error("Comparision between incompatible types: " + ltp.type_name + " and " + rtp.type_name);
                }
            }else if(ltp.is_exprPath && !rtp.is_exprPath){
                if(auto *p = dynamic_cast<ExprLiteral *>(& *node.right)){
                    if(ltp.type_name == "i32"){
                        if(p->type != INTEGER_LITERAL){
                            throw std::runtime_error("Comparision between incompatible types: i32 and non-integer");
                        }
                    }else if(ltp.type_name == "u32" || ltp.type_name == "usize"){
                        if(p->type != INTEGER_LITERAL || p->literal.find('-') != std::string::npos){
                            throw std::runtime_error("Comparision between incompatible types: " + ltp.type_name + " and non-unsigned-integer");
                        }
                    }else if(ltp.type_name == "isize"){
                        if(p->type != INTEGER_LITERAL){
                            throw std::runtime_error("Comparision between incompatible types: isize and non-integer");
                        }
                    }else if(ltp.type_name == "bool"){
                        if(p->type != TRUE && p->type != FALSE){
                            throw std::runtime_error("Comparision between incompatible types: bool and non-boolean");
                        }
                    }else if(ltp.type_name == "char"){
                        if(p->type != CHAR_LITERAL){
                            throw std::runtime_error("Comparision between incompatible types: char and non-char");
                        }
                    }else if(ltp.type_name == "str"){
                        if(p->type != STRING_LITERAL){
                            throw std::runtime_error("Comparision between incompatible types: str and non-string");
                        }
                    }else{
                        throw std::runtime_error("Comparision between incompatible types: struct and literal.");
                    }
                }
            }else if(!ltp.is_exprPath && rtp.is_exprPath){
                if(auto *p = dynamic_cast<ExprLiteral *>(& *node.left)){
                    if(rtp.type_name == "i32"){
                        if(p->type != INTEGER_LITERAL){
                            throw std::runtime_error("Comparision between incompatible types: i32 and non-integer");
                        }
                    }else if(rtp.type_name == "u32" || rtp.type_name == "usize"){
                        if(p->type != INTEGER_LITERAL || p->literal.find('-') != std::string::npos){
                            throw std::runtime_error("Comparision between incompatible types: " + rtp.type_name + " and non-unsigned-integer");
                        }
                    }else if(rtp.type_name == "isize"){
                        if(p->type != INTEGER_LITERAL){
                            throw std::runtime_error("Comparision between incompatible types: isize and non-integer");
                        }
                    }else if(rtp.type_name == "bool"){
                        if(p->type != TRUE && p->type != FALSE){
                            throw std::runtime_error("Comparision between incompatible types: bool and non-boolean");
                        }
                    }else if(rtp.type_name == "char"){
                        if(p->type != CHAR_LITERAL){
                            throw std::runtime_error("Comparision between incompatible types: char and non-char");
                        }
                    }else if(rtp.type_name == "str"){
                        if(p->type != STRING_LITERAL){
                            throw std::runtime_error("Comparision between incompatible types: str and non-string");
                        }
                    }else{
                        throw std::runtime_error("Comparision between incompatible types: struct and literal.");
                    }
                }
            }else{
                if(auto *p = dynamic_cast<ExprLiteral *>(& *node.left)){
                    if(auto *q = dynamic_cast<ExprLiteral *>(& *node.right)){
                        if(p->type != q->type){
                            throw std::runtime_error("Comparision between incompatible literal types");
                        }
                    }
                }
            }
        }

        // Type cast expression
        if(node.op == AS_CAST){
            node.left->accept(*this);
            if(auto *p = dynamic_cast<ExprPath *>(& *node.right)){
                if(p->pathSecond == nullptr){
                    if(p->pathFirst->pathSegments.type == IDENTIFIER) {
                        std::string id = p->pathFirst->pathSegments.identifier;
                        if(id != "i32" && id != "u32" && id != "isize" && id != "usize" && id != "bool" && id != "char" && id != "String"){
                            auto symbol = current_scope->lookupTypeSymbol(id);
                            if(!symbol) {
                                throw std::runtime_error("Type symbol not found: " + p->pathFirst->pathSegments.identifier);
                            }
                        }
                    }
                }
            }
        }

        //Arithimetic
        if(node.op == PLUS || node.op == MINUS || node.op == MULTIPLY || node.op == DIVIDE || node.op == MODULO ||
           node.op == AND || node.op == OR || node.op == XOR || node.op == LEFT_SHIFT || node.op == RIGHT_SHIFT){
            auto leftType = std::shared_ptr<Type>();
            bool isLeftPointer = false;
            auto rightType = std::shared_ptr<Type>();
            bool isRightPointer = false;
            if(auto *p = dynamic_cast<ExprPath *>(& *node.left)){
                if(p->pathSecond == nullptr){
                    if(p->pathFirst->pathSegments.type == IDENTIFIER) {
                        auto symbol = current_scope->lookupValueSymbol(p->pathFirst->pathSegments.identifier);
                        if(!symbol) {
                            throw std::runtime_error("Value symbol not found: " + p->pathFirst->pathSegments.identifier);
                        }
                        if(symbol->symbol_type == Variable){
                            auto varSymbol = std::dynamic_pointer_cast<VariableSymbol>(symbol);
                            if(auto *q = dynamic_cast<Type *>(& *varSymbol->type)){
                                isLeftPointer = true;
                                leftType = std::make_shared<Type>(*q);
                            }
                        }else if(symbol->symbol_type == Const){
                            auto constSymbol = std::dynamic_pointer_cast<ConstSymbol>(symbol);
                            if(auto *q = dynamic_cast<Type *>(& *constSymbol->type)){
                                isLeftPointer = true;
                                leftType = std::make_shared<Type>(*q);
                            }
                        }else if(symbol->symbol_type == Function){
                            auto funcSymbol = std::dynamic_pointer_cast<FunctionSymbol>(symbol);
                            if(auto *q = dynamic_cast<Type *>(& *funcSymbol->return_type)){
                                isLeftPointer = true;
                                leftType = std::make_shared<Type>(*q);
                            }else if(auto *q = dynamic_cast<TypeUnit *>(& *funcSymbol->return_type)){
                                throw std::runtime_error("Arithmetic operation on function with void return type");
                            }else if(!funcSymbol->return_type){
                                throw std::runtime_error("Arithmetic operation on function with no return type");
                            }
                        }
                    }
                }
            }else if(auto *p = dynamic_cast<ExprCall *>(& *node.left)){
                if(auto *q = dynamic_cast<ExprPath *>(& *p->expr)){
                    if(q->pathSecond == nullptr){
                        if(q->pathFirst->pathSegments.type == IDENTIFIER) {
                            auto symbol = current_scope->lookupValueSymbol(q->pathFirst->pathSegments.identifier);
                            if(!symbol) {
                                throw std::runtime_error("Value symbol not found: " + q->pathFirst->pathSegments.identifier);
                            }
                            if(symbol->symbol_type == Function){
                                auto funcSymbol = std::dynamic_pointer_cast<FunctionSymbol>(symbol);
                                if(auto *r = dynamic_cast<Type *>(& *funcSymbol->return_type)){
                                    isLeftPointer = true;
                                    leftType = std::make_shared<Type>(*r);
                                }else if(auto *r = dynamic_cast<TypeUnit *>(& *funcSymbol->return_type)){
                                    throw std::runtime_error("Arithmetic operation on function with void return type");
                                }else if(!funcSymbol->return_type){
                                    throw std::runtime_error("Arithmetic operation on function with no return type");
                                }
                            }else{
                                throw std::runtime_error("Arithmetic operation on non-function");
                            }
                        }
                    }
                }
            }
            if(auto *p = dynamic_cast<ExprPath *>(& *node.right)){
                if(p->pathSecond == nullptr){
                    if(p->pathFirst->pathSegments.type == IDENTIFIER) {
                        auto symbol = current_scope->lookupValueSymbol(p->pathFirst->pathSegments.identifier);
                        if(!symbol) {
                            throw std::runtime_error("Value symbol not found: " + p->pathFirst->pathSegments.identifier);
                        }
                        if(symbol->symbol_type == Variable){
                            auto varSymbol = std::dynamic_pointer_cast<VariableSymbol>(symbol);
                            if(auto *q = dynamic_cast<Type *>(& *varSymbol->type)){
                                isRightPointer = true;
                                rightType = std::make_shared<Type>(*q);
                            }
                        }else if(symbol->symbol_type == Const){
                            auto constSymbol = std::dynamic_pointer_cast<ConstSymbol>(symbol);
                            if(auto *q = dynamic_cast<Type *>(& *constSymbol->type)){
                                isRightPointer = true;
                                rightType = std::make_shared<Type>(*q);
                            }
                        }else if(symbol->symbol_type == Function){
                            auto funcSymbol = std::dynamic_pointer_cast<FunctionSymbol>(symbol);
                            if(auto *q = dynamic_cast<Type *>(& *funcSymbol->return_type)){
                                isRightPointer = true;
                                rightType = std::make_shared<Type>(*q);
                            }else if(auto *q = dynamic_cast<TypeUnit *>(& *funcSymbol->return_type)){
                                throw std::runtime_error("Arithmetic operation on function with void return type");
                            }else if(!funcSymbol->return_type){
                                throw std::runtime_error("Arithmetic operation on function with no return type");
                            }
                        }
                    }
                }
            }else if(auto *p = dynamic_cast<ExprCall *>(& *node.right)){
                if(auto *q = dynamic_cast<ExprPath *>(& *p->expr)){
                    if(q->pathSecond == nullptr){
                        if(q->pathFirst->pathSegments.type == IDENTIFIER) {
                            auto symbol = current_scope->lookupValueSymbol(q->pathFirst->pathSegments.identifier);
                            if(!symbol) {
                                throw std::runtime_error("Value symbol not found: " + q->pathFirst->pathSegments.identifier);
                            }
                            if(symbol->symbol_type == Function){
                                auto funcSymbol = std::dynamic_pointer_cast<FunctionSymbol>(symbol);
                                if(auto *r = dynamic_cast<Type *>(& *funcSymbol->return_type)){
                                    isRightPointer = true;
                                    rightType = std::make_shared<Type>(*r);
                                }else if(auto *r = dynamic_cast<TypeUnit *>(& *funcSymbol->return_type)){
                                    throw std::runtime_error("Arithmetic operation on function with void return type");
                                }else if(!funcSymbol->return_type){
                                    throw std::runtime_error("Arithmetic operation on function with no return type");
                                }
                            }else{
                                throw std::runtime_error("Arithmetic operation on non-function");
                            }
                        }
                    }
                }
            }
            if(isLeftPointer && isRightPointer){
                if(leftType->type != rightType->type){
                    throw std::runtime_error("Arithmetic operation between incompatible types");
                }
                if(leftType->type != I32 && leftType->type != U32 && leftType->type != ISIZE && leftType->type != USIZE){
                    throw std::runtime_error("Arithmetic operation between non-integer types");
                }
            }else if(isLeftPointer && !isRightPointer){
                if(auto *p = dynamic_cast<ExprLiteral *>(& *node.right)){
                    if(p->type != INTEGER_LITERAL){
                        throw std::runtime_error("Arithmetic operation between incompatible types");
                    }
                }
            }else if(!isLeftPointer && isRightPointer){
                if(auto *p = dynamic_cast<ExprLiteral *>(& *node.left)){
                    if(p->type != INTEGER_LITERAL){
                        throw std::runtime_error("Arithmetic operation between incompatible types");
                    }
                }
            }else{
                if(auto *p = dynamic_cast<ExprLiteral *>(& *node.left)){
                    if(auto *q = dynamic_cast<ExprLiteral *>(& *node.right)){
                        if(p->type != INTEGER_LITERAL || q->type != INTEGER_LITERAL){
                            throw std::runtime_error("Arithmetic operation between incompatible literal types");
                        }
                    }
                }
            }
        }
    }

    void visit(ExprOpunary &node) override{
        node.right->accept(*this);
    }

    void visit(ExprPath &node) override{
        if(node.pathSecond == nullptr){
            if(node.pathFirst->pathSegments.type == IDENTIFIER) {
                auto symbol = current_scope->lookupValueSymbol(node.pathFirst->pathSegments.identifier);
                if(!symbol) {
                    throw std::runtime_error("Value symbol not found: " + node.pathFirst->pathSegments.identifier);
                }else{
                    node.resolvedSymbol1 = symbol;
                }
            }
        }
    }

    void visit(ExprReturn &node) override{
        if(node.expr){
            node.expr->accept(*this);
        }
    }

    void visit(ExprStruct &node) override{
        /*node.pathInExpr->accept(*this);
        for(auto &field : node.structExprFields) {
            field.expr->accept(*this);
        }*/
        if(auto *p = dynamic_cast<ExprPath *>(& *node.pathInExpr)){
            if(p->pathSecond == nullptr){
                if(p->pathFirst->pathSegments.type == IDENTIFIER){
                    auto symbol = current_scope->lookupTypeSymbol(p->pathFirst->pathSegments.identifier);
                    if(!symbol) {
                        throw std::runtime_error("Type symbol not found: " + p->pathFirst->pathSegments.identifier);
                    }
                    if(symbol->symbol_type != Struct) {
                        throw std::runtime_error("Type symbol is not a struct: " + p->pathFirst->pathSegments.identifier);
                    }
                    auto structSymbol = std::dynamic_pointer_cast<StructSymbol>(symbol);  
                    if(structSymbol->fields.size() != node.structExprFields.size()){
                        throw std::runtime_error("Struct field count mismatch: " + p->pathFirst->pathSegments.identifier);
                    }
                    for(auto &field : node.structExprFields) {
                        bool field_found = false;
                        for(auto &struct_field : structSymbol->fields) {
                            if(struct_field.name == field.identifier) {
                                field_found = true;
                                if(auto *q = dynamic_cast<Type *>(& *struct_field.type)){
                                    if(auto *r = dynamic_cast<ExprLiteral *>(& *field.expr)){
                                        if(q->type == I32 || q->type == U32 || q->type == USIZE || q->type == ISIZE){
                                            if(r->type != INTEGER_LITERAL){
                                                throw std::runtime_error("Struct field type mismatch: " + field.identifier);
                                            }
                                        }
                                        //TODO left with more type check
                                    }
                                }
                                break;
                            }
                        }
                        if(!field_found) {
                            throw std::runtime_error("Field not found in struct: " + field.identifier);
                        }
                        field.expr->accept(*this);
                    }
                }
            }

        }
    }

    void visit(ExprUnderscore &node) override{}

    //Item
    void visit(Item &node) override {
        if(auto *p = dynamic_cast<ItemConstDecl *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ItemEnumDecl *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ItemFnDecl *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ItemImplDecl *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ItemStructDecl *>(& node)) {    
            p->accept(*this);
        }else if(auto *p = dynamic_cast<ItemTraitDecl *>(& node)) {
            p->accept(*this);
        }else{
            std::cerr << "Unknown Item type in NameResolver\n";
        }
    }

    void visit(ItemConstDecl &node) override{
        /*if(current_scope != global_scope_builder.global_scope){
            std::shared_ptr<ConstSymbol> symbol = std::make_shared<ConstSymbol>();
            symbol->symbol_type = Const;
            symbol->identifier = node.identifier;
            symbol->type = node.type;
            symbol->value = node.expr;
            current_scope->addValueSymbol(node.identifier, symbol);
        }*/
        if(auto *p = dynamic_cast<Path *>(& *node.type)) {
            if(p->pathSegments.type == IDENTIFIER) {
                std::string id = p->pathSegments.identifier;
                auto symbol = current_scope->lookupTypeSymbol(id);
                if(!symbol) {
                    throw std::runtime_error("Value symbol not found: " + id);
                }else{
                    p->resolvedSymbol = symbol;
                }
            }
        }
        if(node.expr){
            node.expr->accept(*this);
        }
    }

    void visit(ItemEnumDecl &node) override{
        if(current_scope != global_scope_builder.global_scope){
            std::shared_ptr<EnumSymbol> symbol = std::make_shared<EnumSymbol>();
            symbol->symbol_type = Enum;
            symbol->identifier = node.identifier;
            for (auto &variant : node.item_enum) {
                symbol->variants.push_back(variant);
            }
            current_scope->addTypeSymbol(node.identifier, symbol);
        }
        for(auto &variant : node.item_enum) {
            std::shared_ptr<EnumVariantSymbol> variantSymbol = std::make_shared<EnumVariantSymbol>();
            variantSymbol->symbol_type = EnumVariant;
            variantSymbol->identifier = variant;
            variantSymbol->enum_decl = std::make_shared<ItemEnumDecl>(node);
            current_scope->addValueSymbol(variant, variantSymbol);
        }
    }

    bool checkReturnInIf(std::shared_ptr<ExprIf> ifExpr) {
        bool is_return = false;
        if(ifExpr->thenBlock){
            if(checkReturn(ifExpr->thenBlock)){
                is_return = true;
            }
        }
        if(!is_return && ifExpr->elseBlock){
            if(auto *p = dynamic_cast<ExprIf *>(& *ifExpr->elseBlock)){
                if(checkReturnInIf(std::make_shared<ExprIf>(*p))){
                    is_return = true;
                }
            }else if(auto *p = dynamic_cast<ExprBlock *>(& *ifExpr->elseBlock)){
                if(checkReturn(std::make_shared<ExprBlock>(*p))){
                    is_return = true;
                }
            }else if(auto *p = dynamic_cast<ExprStruct *>(& *ifExpr->elseBlock)){
                is_return = true;
            }
        }
        return is_return;
    }

    bool checkReturn(std::shared_ptr<ExprBlock> block) {
        for(auto &stmt : block->statements) {
            if(auto *p = dynamic_cast<StmtExpr *>(& *stmt)){
                if(auto *q = dynamic_cast<ExprReturn *>(& *p->stmtExpr)){
                    return true;
                }else if(auto *q = dynamic_cast<ExprBlock *>(& *p->stmtExpr)){
                    if(checkReturn(std::make_shared<ExprBlock>(*q))){
                        return true;
                    }
                }else if(auto *q = dynamic_cast<ExprIf *>(& *p->stmtExpr)){
                    if(checkReturnInIf(std::make_shared<ExprIf>(*q))){
                        return true;
                    }
                }else if(auto *q = dynamic_cast<ExprStruct *>(& *p->stmtExpr)){
                    return true;
                }else if(auto *q = dynamic_cast<ExprLoop *>(& *p->stmtExpr)){
                    if(q->PredicateLoopExpression){
                        if(checkReturn(q->PredicateLoopExpression)){
                            return true;
                        }
                    }else if(q->infinitieLoop){
                        if(checkReturn(q->infinitieLoop)){
                            return true;
                        }
                    }
                }else if(auto *q = dynamic_cast<ExprBreak *>(& *p->stmtExpr)){
                    return true;
                }
            }
        }
        if(block->ExpressionWithoutBlock){
            return true;
        }
        return false;
    }

    void visit(ItemFnDecl &node) override{
        /*if(current_scope != global_scope_builder.global_scope){
            std::shared_ptr<FunctionSymbol> symbol = std::make_shared<FunctionSymbol>();
            symbol->symbol_type = Function;
            symbol->identifier = node.identifier;
            if(node.returnType){
                symbol->return_type = node.returnType;
            }else{
                symbol->return_type = std::make_shared<TypeUnit>(TypeUnit());
            }
            if(node.fnParameters.SelfParam.short_self.is_and){
                symbol->is_ref = true;
            }
            if(node.fnParameters.SelfParam.short_self.is_mut){
                symbol->is_mut = true;
            }
            if(node.fnParameters.FunctionParam.size() > 0){
                for(auto &param : node.fnParameters.FunctionParam){
                    if(auto *p = dynamic_cast<PatternIdentifier *>(& *param.pattern)){
                        symbol->parameters.push_back({p->identifier,param.type});
                    }else if(auto *p = dynamic_cast<PatternReference *>(& *param.pattern)){
                        if(auto *q = dynamic_cast<PatternIdentifier *>(& *p->patternWithoutRange)){
                            symbol->parameters.push_back({q->identifier,param.type});
                        }else{
                            std::cerr << "Unsupported pattern in function parameter in NameResolver\n";
                        }
                    }
                }
            }
            current_scope->addValueSymbol(node.identifier, symbol);
        }*/
        auto fn_scope = std::make_shared<ScopeNode>();
        fn_scope->parent = current_scope;
        fn_scope->ast_node = std::make_shared<ItemFnDecl>(node);
        current_scope = fn_scope;
        for(auto &param: node.fnParameters.FunctionParam){
            std::shared_ptr<VariableSymbol> varSymbol = std::make_shared<VariableSymbol>();
            varSymbol->symbol_type = Variable;
            if(auto *p = dynamic_cast<PatternIdentifier *>(& *param.pattern)){
                varSymbol->identifier = p->identifier;
                varSymbol->type = param.type;
                varSymbol->is_mut = p->is_mut;
                if(auto *q = dynamic_cast<TypeReference *>(& *param.type)){
                    varSymbol->is_mut = q->is_mut;
                }
                current_scope->addValueSymbol(p->identifier, varSymbol);
            }else if(auto *p = dynamic_cast<PatternReference *>(& *param.pattern)){
                if(auto *q = dynamic_cast<PatternIdentifier *>(& *p->patternWithoutRange)){
                    varSymbol->identifier = q->identifier;
                    varSymbol->type = param.type;
                    varSymbol->is_mut = q->is_mut || p->is_mut;
                    if(auto *r = dynamic_cast<TypeReference *>(& *param.type)){
                        varSymbol->is_mut = r->is_mut;
                    }
                    current_scope->addValueSymbol(q->identifier, varSymbol);
                }
            }
            if(auto *p = dynamic_cast<Path *>(& *param.type)){
                if(p->pathSegments.type == IDENTIFIER) {
                    std::string id = p->pathSegments.identifier;
                    auto symbol = current_scope->lookupTypeSymbol(id);
                    if(!symbol) {
                        throw std::runtime_error("Value symbol not found: " + id);
                    }else{
                        p->resolvedSymbol = symbol;
                    }
                }
            }
        }
        if(node.returnType){
            if(auto *p = dynamic_cast<Path *>(& *node.returnType)){
                if(p->pathSegments.type == IDENTIFIER) {
                    std::string id = p->pathSegments.identifier;
                    auto symbol = current_scope->lookupTypeSymbol(id);
                    if(!symbol) {
                        throw std::runtime_error("Type symbol not found: " + id);
                    }else{
                        p->resolvedSymbol = symbol;
                    }
                }
            }
        }
        if(node.fnBody){
            for(auto &stmt : node.fnBody->statements) {
                if(auto *p = dynamic_cast<StmtItem *>(& *stmt)){
                    if(auto *q = dynamic_cast<ItemConstDecl *>(& *p->stmt_item)){
                        //todo
                        std::shared_ptr<ConstSymbol> symbol = std::make_shared<ConstSymbol>();
                        symbol->symbol_type = Const;
                        symbol->identifier = q->identifier;
                        symbol->type = q->type;
                        symbol->value = q->expr;
                        current_scope->addValueSymbol(q->identifier, symbol);
                    }else if(auto *q = dynamic_cast<ItemEnumDecl *>(& *p->stmt_item)){
                        //todo
                        std::shared_ptr<EnumSymbol> symbol = std::make_shared<EnumSymbol>();
                        symbol->symbol_type = Enum;
                        symbol->identifier = q->identifier;
                        if(q->item_enum.size() > 0){
                            for(auto &variant : q->item_enum) {
                                symbol->variants.push_back(variant);
                            }
                        }
                        current_scope->addTypeSymbol(q->identifier, symbol);
                    }else if(auto *q = dynamic_cast<ItemFnDecl *>(& *p->stmt_item)){
                        //todo
                        std::shared_ptr<FunctionSymbol> symbol = std::make_shared<FunctionSymbol>();
                        symbol->symbol_type = Function;
                        symbol->identifier = q->identifier;
                        if(q->fnParameters.SelfParam.short_self.is_and){
                            symbol->is_ref = true;
                        }
                        if(q->fnParameters.SelfParam.short_self.is_mut){
                            symbol->is_mut = true;
                        }
                        if(q->fnParameters.FunctionParam.size() > 0){
                            for(auto &param : q->fnParameters.FunctionParam){
                                if(auto *r = dynamic_cast<PatternIdentifier *>(& *param.pattern)){
                                    symbol->parameters.push_back({r->identifier,param.type});
                                }else if(auto *r = dynamic_cast<PatternReference *>(& *param.pattern)){
                                    if(auto *s = dynamic_cast<PatternIdentifier *>(& *r->patternWithoutRange)){
                                        symbol->parameters.push_back({s->identifier,param.type});
                                    }else{
                                        std::cerr << "Unsupported pattern in function parameter in NameResolver\n";
                                    }
                                }
                            }
                        }
                        if(q->returnType){
                            symbol->return_type = q->returnType;
                        }else{
                            symbol->return_type = std::make_shared<TypeUnit>(TypeUnit());
                        }
                        current_scope->addValueSymbol(q->identifier, symbol);
                    }else if(auto *q = dynamic_cast<ItemImplDecl *>(& *p->stmt_item)){
                        //todo
                        continue;
                    }else if(auto *q = dynamic_cast<ItemStructDecl *>(& *p->stmt_item)){
                        //todo
                        std::shared_ptr<StructSymbol> symbol = std::make_shared<StructSymbol>();
                        symbol->symbol_type = Struct;
                        symbol->identifier = q->identifier;
                        for(auto &field : q->item_struct) {
                            symbol->fields.push_back({field.identifier, field.structElem});
                        }
                        current_scope->addTypeSymbol(q->identifier, symbol);
                    }else if(auto *q = dynamic_cast<ItemTraitDecl *>(& *p->stmt_item)){
                        //todo  
                        std::shared_ptr<TraitSymbol> symbol = std::make_shared<TraitSymbol>();
                        symbol->symbol_type = Trait;
                        symbol->identifier = q->identifier;
                        for(auto &constraint : q->item_trait_const) {
                            std::shared_ptr<ConstSymbol> constSymbol = std::make_shared<ConstSymbol>();
                            constSymbol->symbol_type = Const;
                            constSymbol->identifier = constraint->identifier;
                            constSymbol->type = constraint->type;
                            constSymbol->value = constraint->expr;
                            if(symbol->associated_consts.find(constraint->identifier) != symbol->associated_consts.end()) {
                                throw std::runtime_error("Duplicate associated constant in trait: " + constraint->identifier);
                            }
                            symbol->associated_consts[constraint->identifier] = constSymbol;
                        }
                        for(auto &method : q->item_trait_fn) {
                            std::shared_ptr<FunctionSymbol> funcSymbol = std::make_shared<FunctionSymbol>();
                            funcSymbol->symbol_type = Function;
                            funcSymbol->identifier = method->identifier;
                            if(method->returnType){
                                funcSymbol->return_type = method->returnType;
                            }else{
                                funcSymbol->return_type = std::make_shared<TypeUnit>(TypeUnit());
                            }
                            if(method->fnParameters.SelfParam.short_self.is_and){
                                funcSymbol->is_ref = true;
                            }
                            if(method->fnParameters.SelfParam.short_self.is_mut){
                                funcSymbol->is_mut = true;
                            }
                            if(method->fnParameters.FunctionParam.size() > 0){
                                for(auto &param : method->fnParameters.FunctionParam){
                                    if(auto *r = dynamic_cast<PatternIdentifier *>(& *param.pattern)){
                                        funcSymbol->parameters.push_back({r->identifier,param.type});
                                    }else if(auto *r = dynamic_cast<PatternReference *>(& *param.pattern)){
                                        if(auto *s = dynamic_cast<PatternIdentifier *>(& *r->patternWithoutRange)){
                                            funcSymbol->parameters.push_back({s->identifier,param.type});
                                        }else{
                                            std::cerr << "Unsupported pattern in function parameter in NameResolver\n";
                                        }
                                    }
                                }
                            }
                            symbol->methods[method->identifier] = funcSymbol;
                        }
                        current_scope->addTypeSymbol(q->identifier, symbol);
                    }
                }
            }
        }
        if(node.fnBody){
            //node.fnBody->accept(*this);
            for(auto &stmt : node.fnBody->statements) {
                stmt->accept(*this);
            }
            if(node.fnBody->ExpressionWithoutBlock){
                node.fnBody->ExpressionWithoutBlock->accept(*this); 
            }
        }
        
        if(node.fnBody && node.fnBody->ExpressionWithoutBlock){
            if(auto *p = dynamic_cast<ExprPath *>(& *node.fnBody->ExpressionWithoutBlock)){
                if(p->pathSecond == nullptr){
                    if(p->pathFirst->pathSegments.type == IDENTIFIER) {
                        auto symbol = current_scope->lookupValueSymbol(p->pathFirst->pathSegments.identifier);
                        if(!symbol) {
                            throw std::runtime_error("Value symbol not found: " + p->pathFirst->pathSegments.identifier);
                        }
                        if(symbol->symbol_type != Variable) {
                            throw std::runtime_error("Value symbol is not a variable: " + p->pathFirst->pathSegments.identifier);
                        }
                        auto varSymbol = std::dynamic_pointer_cast<VariableSymbol>(symbol);
                        if(auto *q = dynamic_cast<Type *>(& *varSymbol->type)){
                            if(auto *r = dynamic_cast<Type *>(& *node.returnType)){
                                if(q->type != r->type){
                                    throw std::runtime_error("Return type mismatch in function: " + node.identifier);
                                }
                            }else{
                                throw std::runtime_error("Function has no return type: " + node.identifier);
                            }
                        }else if(auto *q = dynamic_cast<TypeArray *>(& *varSymbol->type)){
                            if(auto *r = dynamic_cast<TypeArray *>(& *node.returnType)){
                                if(auto *u1 = dynamic_cast<Type *>(& *q->type)){
                                    if(auto *u2 = dynamic_cast<Type *>(& *r->type)){
                                        if(u1->type != u2->type){
                                            throw std::runtime_error("Return type mismatch in function: " + node.identifier);
                                        }
                                    }else{
                                        throw std::runtime_error("Return type mismatch in function: " + node.identifier);
                                    }
                                }
                            }else{
                                throw std::runtime_error("Return type mismatch in function: " + node.identifier);
                            }
                        }
                    }
                }
            }
        }

        // check for return stmt in if expr
        if(node.returnType){
            if(node.fnBody && node.fnBody->statements.size() > 0){
                if(auto *o = dynamic_cast<StmtExpr *>(& *node.fnBody->statements[node.fnBody->statements.size() - 1])){
                    if(auto *p = dynamic_cast<ExprIf *>(& *o->stmtExpr)){
                        if(p->thenBlock){
                            for(auto &stmt : p->thenBlock->statements) {
                                if(auto *q = dynamic_cast<StmtExpr *>(& *stmt)){
                                    if(auto *r = dynamic_cast<ExprReturn *>(& *q->stmtExpr)){
                                        if(r->expr){
                                            if(auto *s = dynamic_cast<ExprLiteral *>(& *r->expr)){
                                                if(auto *t = dynamic_cast<Type *>(& *node.returnType)){
                                                    if(t->type == I32 || t->type == U32 || t->type == ISIZE || t->type == USIZE){
                                                        if(s->type != INTEGER_LITERAL){
                                                            throw std::runtime_error("Return type mismatch in function: " + node.identifier);
                                                        }
                                                    }else if(t->type == BOOL){
                                                        if(s->type != TRUE && s->type != FALSE){
                                                            throw std::runtime_error("Return type mismatch in function: " + node.identifier);
                                                        }
                                                    }else if(t->type == CHAR){
                                                        if(s->type != CHAR_LITERAL){
                                                            throw std::runtime_error("Return type mismatch in function: " + node.identifier);
                                                        }
                                                    }else if(t->type == STR){
                                                        if(s->type != STRING_LITERAL){
                                                            throw std::runtime_error("Return type mismatch in function: " + node.identifier);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if(p->elseBlock){
                            if(auto *m = dynamic_cast<ExprBlock *>(& *p->elseBlock)){
                                if(m->statements.size() > 0){
                                    for(auto &stmt : m->statements) {
                                        if(auto *q = dynamic_cast<StmtExpr *>(& *stmt)){
                                            if(auto *r = dynamic_cast<ExprReturn *>(& *q->stmtExpr)){
                                                if(r->expr){
                                                    if(auto *s = dynamic_cast<ExprLiteral *>(& *r->expr)){
                                                        if(auto *t = dynamic_cast<Type *>(& *node.returnType)){
                                                            if(t->type == I32 || t->type == U32 || t->type == ISIZE || t->type == USIZE){
                                                                if(s->type != INTEGER_LITERAL){
                                                                    throw std::runtime_error("Return type mismatch in function: " + node.identifier);
                                                                }
                                                            }else if(t->type == BOOL){
                                                                if(s->type != TRUE && s->type != FALSE){
                                                                    throw std::runtime_error("Return type mismatch in function: " + node.identifier);
                                                                }
                                                            }else if(t->type == CHAR){
                                                                if(s->type != CHAR_LITERAL){
                                                                    throw std::runtime_error("Return type mismatch in function: " + node.identifier);
                                                                }
                                                            }else if(t->type == STR){
                                                                if(s->type != STRING_LITERAL){
                                                                    throw std::runtime_error("Return type mismatch in function: " + node.identifier);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }else if(m->ExpressionWithoutBlock){
                                    if(auto *q = dynamic_cast<ExprReturn *>(& *m->ExpressionWithoutBlock)){
                                        if(q->expr){
                                            if(auto *r = dynamic_cast<ExprLiteral *>(& *q->expr)){
                                                if(auto *s = dynamic_cast<Type *>(& *node.returnType)){
                                                    if(s->type == I32 || s->type == U32 || s->type == ISIZE || s->type == USIZE){
                                                        if(r->type != INTEGER_LITERAL){
                                                            throw std::runtime_error("Return type mismatch in function: " + node.identifier);
                                                        }
                                                    }else if(s->type == BOOL){
                                                        if(r->type != TRUE && r->type != FALSE){
                                                            throw std::runtime_error("Return type mismatch in function: " + node.identifier);
                                                        }
                                                    }else if(s->type == CHAR){
                                                        if(r->type != CHAR_LITERAL){
                                                            throw std::runtime_error("Return type mismatch in function: " + node.identifier);
                                                        }
                                                    }else if(s->type == STR){
                                                        if(r->type != STRING_LITERAL){
                                                            throw std::runtime_error("Return type mismatch in function: " + node.identifier);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        if(node.fnBody){
            if(!checkReturn(node.fnBody)){
                if(node.returnType){
                    if(auto *p = dynamic_cast<TypeUnit *>(& *node.returnType)){
                        //nothing
                    }else{
                        throw std::runtime_error("Missing return statement in function: " + node.identifier);
                    }
                }
            }
        }

        // check for Missing return value for non-unit return type
        if(node.returnType){
            if(auto *p = dynamic_cast<TypeUnit *>(& *node.returnType)){
                //nothing
            }else{
                if(node.fnBody){
                    if(!node.fnBody->ExpressionWithoutBlock){
                        if(node.fnBody->statements.size() > 0){
                            auto &last_stmt = node.fnBody->statements.back();
                            if(auto *p = dynamic_cast<StmtExpr *>(& *last_stmt)){
                                if(auto *q = dynamic_cast<ExprIf *>(& *p->stmtExpr)){
                                    if(!q->elseBlock){
                                        throw std::runtime_error("Missing return value for non-unit return type in function: " + node.identifier);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        current_scope = current_scope->parent;
    }

    void visit(ItemImplDecl &node) override{
        if(node.identifier != ""){
            auto symbolTYPE = current_scope->lookupTypeSymbol(node.identifier);
            if(!symbolTYPE) {
                throw std::runtime_error("Type symbol not found: " + node.identifier);
            }
            if(symbolTYPE->symbol_type != Trait) {
                throw std::runtime_error("Type symbol is not a trait: " + node.identifier);
            }
            if(auto *p = dynamic_cast<Path *>(& *node.targetType)){
                if(p->pathSegments.type == IDENTIFIER) {
                    std::string id = p->pathSegments.identifier;
                    auto structTYPE = current_scope->lookupTypeSymbol(id);
                    if(!structTYPE) {
                        throw std::runtime_error("Type symbol not found: " + id);
                    }else{
                        p->resolvedSymbol = symbolTYPE;
                    }
                    auto structSymbol = std::dynamic_pointer_cast<StructSymbol>(structTYPE);
                    for(auto &method : std::dynamic_pointer_cast<TraitSymbol>(symbolTYPE)->methods) {
                        structSymbol->methods.insert({method.first, method.second});
                    }
                    for(auto &const_item :  std::dynamic_pointer_cast<TraitSymbol>(symbolTYPE)->associated_consts) {
                        structSymbol->associated_consts.insert({const_item.first,const_item.second});
                    }
                }
            }
            for(auto &const_item : node.item_trait_const) {
                const_item->accept(*this);
            }
            if(node.item_trait_fn.size() != std::dynamic_pointer_cast<TraitSymbol>(symbolTYPE)->methods.size()) {
                throw std::runtime_error("Impl does not implement all functions of the trait: " + node.identifier);
            }
            for(auto &fn_item : node.item_trait_fn) {
                fn_item->accept(*this); 
            }
        }else{
            if(auto *p = dynamic_cast<Path *>(& *node.targetType)){
                if(p->pathSegments.type == IDENTIFIER){
                    std::string id = p->pathSegments.identifier;
                    auto symbolTYPE = current_scope->lookupTypeSymbol(id);
                    if(!symbolTYPE) {
                        throw std::runtime_error("Type symbol not found: " + id);
                    }else{
                        p->resolvedSymbol = symbolTYPE;
                    }
                }
            }
            for(auto &const_item : node.item_trait_const) {
                const_item->accept(*this);  
            }
            for(auto &fn_item : node.item_trait_fn) {
                fn_item->accept(*this); 
            }
        }
    }

    void visit(ItemStructDecl &node) override{
        /*if(current_scope != global_scope_builder.global_scope){
            std::shared_ptr<StructSymbol> symbol = std::make_shared<StructSymbol>();
            symbol->symbol_type = Struct;
            symbol->identifier = node.identifier;
            for(auto &struct_field: node.item_struct) {
                symbol->fields.push_back({struct_field.identifier, struct_field.structElem});
            }
            current_scope->addTypeSymbol(node.identifier, symbol);
        }*/
        //current_scope->addTypeSymbol(node.identifier, std::make_shared<Symbol>(std::make_shared<ItemStructDecl>(node), Struct, node.identifier));
        for(auto &struct_field: node.item_struct) {
            if(auto *p = dynamic_cast<Path *>(& *struct_field.structElem)){
                if(p->pathSegments.type == IDENTIFIER){
                    std::string id = p->pathSegments.identifier;
                    auto symbol = current_scope->lookupTypeSymbol(id);
                    if(!symbol) {
                        throw std::runtime_error("Value symbol not found: " + id);
                    }else{
                        p->resolvedSymbol = symbol;
                    }
                }
            }
        }
    }

    void visit(ItemTraitDecl &node) override{
        /*if(current_scope != global_scope_builder.global_scope){
            std::shared_ptr<TraitSymbol> symbol = std::make_shared<TraitSymbol>();
            symbol->symbol_type = Trait;
            symbol->identifier = node.identifier;
            current_scope->addTypeSymbol(node.identifier, symbol);
        }*/
        //current_scope->addTypeSymbol(node.identifier, std::make_shared<Symbol>(std::make_shared<ItemTraitDecl>(node), Trait, node.identifier));
        for(auto &const_item : node.item_trait_const) {
            const_item->accept(*this);  
        }
        for(auto &fn_item : node.item_trait_fn) {
            fn_item->accept(*this); 
        }
    }

    //Pattern
    void visit(Pattern &node) override {
        if(auto *p = dynamic_cast<PatternIdentifier *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<PatternLiteral *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<PatternPath *>(& node)) {
            p->accept(*this);     
        }else if(auto *p = dynamic_cast<PatternReference *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<PatternWildCard *>(& node)) {   
            p->accept(*this);
        }else if(auto *p = dynamic_cast<PatternTupleStruct *>(& node)) {
            p->accept(*this);
        }else{
            std::cout << "Unknown Pattern type in PrintVisitor\n";
        }
    }

    void visit(PatternIdentifier &node) override{}

    void visit(PatternLiteral &node) override{}

    void visit(PatternPath &node) override{}

    void visit(PatternReference &node) override{}

    void visit(PatternWildCard &node) override{}

    //Statement
    void visit(Statement &node) override {
        if(auto *p = dynamic_cast<StmtEmpty *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<StmtExpr *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<StmtItem *>(& node)) {
            p->accept(*this);
        }else if(auto *p = dynamic_cast<StmtLet *>(& node)) {
            p->accept(*this);
        }else{
            std::cout << "Unknown Statement type in PrintVisitor\n";
        }
    }

    void visit(StmtEmpty &node) override{}

    void visit(StmtExpr &node) override{
        node.stmtExpr->accept(*this);
    }

    void visit(StmtItem &node) override{
        node.stmt_item->accept(*this);
    }

    void visit(StmtLet &node) override{
        if(auto *p = dynamic_cast<PatternIdentifier *>(& *node.PatternNoTopAlt)){
            std::shared_ptr<VariableSymbol> symbol = std::make_shared<VariableSymbol>();
            symbol->symbol_type = Variable;
            symbol->identifier = p->identifier;
            symbol->type = node.type;
            if(p->is_mut){
                symbol->is_mut = true;
            }else{
                if(auto *q = dynamic_cast<TypeReference *>(& *node.type)){
                    if(q->is_mut){
                        symbol->is_mut = true;
                    }
                }else{
                    symbol->is_mut = false;
                }
            }
            current_scope->addValueSymbol(p->identifier, symbol);
        }else if(auto *p = dynamic_cast<PatternReference *>(& *node.PatternNoTopAlt)){
            if(auto *q = dynamic_cast<PatternIdentifier *>(& *p->patternWithoutRange)){
                std::shared_ptr<VariableSymbol> symbol = std::make_shared<VariableSymbol>();
                symbol->symbol_type = Variable;
                symbol->identifier = q->identifier;
                symbol->type = node.type;
                if(p->is_mut){
                    symbol->is_mut = true;
                }else{
                    if(auto *q = dynamic_cast<TypeReference *>(& *node.type)){
                        if(q->is_mut){
                            symbol->is_mut = true;
                        }
                    }else{
                        symbol->is_mut = false;
                    }
                }
                current_scope->addValueSymbol(q->identifier,symbol);
            }
        }
        if(auto *p = dynamic_cast<Path *>(& *node.type)){
            if(p->pathSegments.type == IDENTIFIER) {
                std::string id = p->pathSegments.identifier;
                auto symbol = current_scope->lookupTypeSymbol(id);
                if(!symbol) {
                    throw std::runtime_error("Value symbol not found: " + id);
                }else{
                    p->resolvedSymbol = symbol;
                }
            }
        }
        //type checker in let stmt
        node.expression->accept(*this);
        //first index expr
        if(auto *p = dynamic_cast<ExprIndex *>(& *node.expression)){
            if(auto *q = dynamic_cast<ExprPath *>(& *p->name)){
                if(q->pathSecond == nullptr){
                    if(q->pathFirst->pathSegments.type == IDENTIFIER) {
                        auto symbol = current_scope->lookupValueSymbol(q->pathFirst->pathSegments.identifier);
                        if(!symbol) {
                            throw std::runtime_error("Value symbol not found: " + q->pathFirst->pathSegments.identifier);
                        }
                        if(symbol->symbol_type != Variable) {
                            throw std::runtime_error("Value symbol is not a variable: " + q->pathFirst->pathSegments.identifier);
                        }
                        auto varSymbol = std::dynamic_pointer_cast<VariableSymbol>(symbol);
                        if(auto *r = dynamic_cast<TypeArray *>(& *varSymbol->type)){
                            if(auto *s = dynamic_cast<Type *>(& *r->type)){
                                if(auto *t = dynamic_cast<Type *>(& *node.type)){
                                    if(s->type != t->type){
                                        throw std::runtime_error("Type mismatch in let statement: " + q->pathFirst->pathSegments.identifier);
                                    }else{
                                        //may left with a size check
                                    }
                                }else{
                                    throw std::runtime_error("Type is not a simple type in let statement: " + q->pathFirst->pathSegments.identifier);
                                }
                            }else if(auto *s = dynamic_cast<TypeArray *>(& *r->type)){
                                if(auto *t = dynamic_cast<TypeArray *>(& *node.type)){
                                    if(auto *u1 = dynamic_cast<Type *>(& *s->type)){
                                        if(auto *u2 = dynamic_cast<Type *>(& *t->type)){
                                            if(u1->type != u2->type){
                                                throw std::runtime_error("Type mismatch in let statement: " + q->pathFirst->pathSegments.identifier);
                                            }else{
                                                if(auto *v1 = dynamic_cast<ExprLiteral *>(& *s->expr)){
                                                    if(auto *v2 = dynamic_cast<ExprLiteral *>(& *t->expr)){
                                                        if(v1->type == INTEGER_LITERAL && v2->type == INTEGER_LITERAL){
                                                            if(v1->integer != v2->integer){
                                                                throw std::runtime_error("Array size mismatch in let statement: " + q->pathFirst->pathSegments.identifier);
                                                            }
                                                        }else{
                                                            throw std::runtime_error("Array size is not an integer literal in let statement: " + q->pathFirst->pathSegments.identifier);
                                                        }
                                                    }
                                                }
                                            }
                                        }else{
                                            throw std::runtime_error("Type is not a simple type in let statement: " + q->pathFirst->pathSegments.identifier);
                                        }
                                    }
                                }else{
                                    throw std::runtime_error("Type is not an array type in let statement: " + q->pathFirst->pathSegments.identifier);
                                }
                            }
                        }else if(auto *a = dynamic_cast<TypeReference *>(& *varSymbol->type)){
                            if(auto *r = dynamic_cast<TypeArray *>(& *a->typeNoBounds)){
                                if(auto *s = dynamic_cast<Type *>(& *r->type)){
                                    if(auto *t = dynamic_cast<Type *>(& *node.type)){
                                        if(s->type != t->type){
                                            throw std::runtime_error("Type mismatch in let statement: " + q->pathFirst->pathSegments.identifier);
                                        }else{
                                            //may left with a size check
                                        }
                                    }else{
                                        throw std::runtime_error("Type is not a simple type in let statement: " + q->pathFirst->pathSegments.identifier);
                                    }
                                }else if(auto *s = dynamic_cast<TypeArray *>(& *r->type)){
                                    if(auto *t = dynamic_cast<TypeArray *>(& *node.type)){
                                        if(auto *u1 = dynamic_cast<Type *>(& *s->type)){
                                            if(auto *u2 = dynamic_cast<Type *>(& *t->type)){
                                                if(u1->type != u2->type){
                                                    throw std::runtime_error("Type mismatch in let statement: " + q->pathFirst->pathSegments.identifier);
                                                }else{
                                                    if(auto *v1 = dynamic_cast<ExprLiteral *>(& *s->expr)){
                                                        if(auto *v2 = dynamic_cast<ExprLiteral *>(& *t->expr)){
                                                            if(v1->type == INTEGER_LITERAL && v2->type == INTEGER_LITERAL){
                                                                if(v1->integer != v2->integer){
                                                                    throw std::runtime_error("Array size mismatch in let statement: " + q->pathFirst->pathSegments.identifier);
                                                                }
                                                            }else{
                                                                throw std::runtime_error("Array size is not an integer literal in let statement: " + q->pathFirst->pathSegments.identifier);
                                                            }
                                                        }
                                                    }
                                                }
                                            }else{
                                                throw std::runtime_error("Type is not a simple type in let statement: " + q->pathFirst->pathSegments.identifier);
                                            }
                                        }
                                    }else{
                                        throw std::runtime_error("Type is not an array type in let statement: " + q->pathFirst->pathSegments.identifier);
                                    }
                                }
                            }
                        }else{
                            throw std::runtime_error("Type is not an array: " + q->pathFirst->pathSegments.identifier);
                        }
                    }
                }
            }
        }

        //array expr
        if(auto *o = dynamic_cast<TypeArray *>(& *node.type)){
            if(auto *p = dynamic_cast<ExprPath *>(& *node.expression)){
                if(p->pathSecond == nullptr){
                    if(p->pathFirst->pathSegments.type == IDENTIFIER){
                        auto symbol = current_scope->lookupValueSymbol(p->pathFirst->pathSegments.identifier);
                        if(!symbol) {
                            throw std::runtime_error("Value symbol not found: " + p->pathFirst->pathSegments.identifier);
                        }
                        if(symbol->symbol_type != Variable) {
                            throw std::runtime_error("Value symbol is not a variable: " + p->pathFirst->pathSegments.identifier);
                        }
                        auto varSymbol = std::dynamic_pointer_cast<VariableSymbol>(symbol);
                        if(auto *q = dynamic_cast<TypeArray *>(& *varSymbol->type)){
                            if(auto *r = dynamic_cast<Type *>(& *q->type)){
                                if(auto *s = dynamic_cast<Type *>(& *o->type)){
                                    if(r->type != s->type){
                                        throw std::runtime_error("Type mismatch in let statement: " + p->pathFirst->pathSegments.identifier);
                                    }else{
                                        if(auto *t1 = dynamic_cast<ExprLiteral *>(& *q->expr)){
                                            if(auto *t2 = dynamic_cast<ExprLiteral *>(& *o->expr)){
                                                if(t1->type == INTEGER_LITERAL && t2->type == INTEGER_LITERAL){
                                                    if(t1->integer != t2->integer){
                                                        throw std::runtime_error("Array size mismatch in let statement: " + p->pathFirst->pathSegments.identifier);
                                                    }
                                                }else{
                                                    throw std::runtime_error("Array size is not an integer literal in let statement: " + p->pathFirst->pathSegments.identifier);
                                                }
                                            }
                                        }
                                        //Const expr path check
                                        //todo todo todo !!!
                                        int t1_size = -1;
                                        int t2_size = -1;
                                        if(auto *t1 = dynamic_cast<ExprPath *>(& *q->expr)){
                                            if(t1->pathSecond == nullptr){
                                                if(t1->pathFirst->pathSegments.type == IDENTIFIER) {
                                                    auto symbol = current_scope->lookupValueSymbol(t1->pathFirst->pathSegments.identifier);
                                                    if(!symbol) {
                                                        throw std::runtime_error("Value symbol not found: " + t1->pathFirst->pathSegments.identifier);
                                                    }
                                                    if(symbol->symbol_type != Const) {
                                                        throw std::runtime_error("Value symbol is not a const: " + t1->pathFirst->pathSegments.identifier);
                                                    }
                                                    auto constSymbol = std::dynamic_pointer_cast<ConstSymbol>(symbol);
                                                    if(auto *u = dynamic_cast<ExprLiteral *>(& *constSymbol->value)){
                                                        if(u->type == INTEGER_LITERAL){
                                                            t1_size = u->integer;
                                                        }else{
                                                            throw std::runtime_error("Const expr is not an integer literal in let statement: " + t1->pathFirst->pathSegments.identifier);   
                                                        }
                                                    }
                                                }
                                            }
                                        }else if(auto *t1 = dynamic_cast<ExprOpbinary *>(& *q->expr)){
                                            if(t1->op == PLUS || t1->op == MINUS || t1->op == MULTIPLY || t1->op == DIVIDE){
                                                int left_val = -1;
                                                int right_val = -1;
                                                if(auto *t3 = dynamic_cast<ExprPath *>(& *t1->left)){
                                                    if(t3->pathSecond == nullptr){
                                                        if(t3->pathFirst->pathSegments.type == IDENTIFIER) {
                                                            auto symbol = current_scope->lookupValueSymbol(t3->pathFirst->pathSegments.identifier);
                                                            if(!symbol) {
                                                                throw std::runtime_error("Value symbol not found: " + t3->pathFirst->pathSegments.identifier);
                                                            }
                                                            if(symbol->symbol_type != Const) {
                                                                throw std::runtime_error("Value symbol is not a const: " + t3->pathFirst->pathSegments.identifier);
                                                            }
                                                            auto constSymbol = std::dynamic_pointer_cast<ConstSymbol>(symbol);
                                                            if(auto *u = dynamic_cast<ExprLiteral *>(& *constSymbol->value)){
                                                                if(u->type == INTEGER_LITERAL){
                                                                    left_val = u->integer;
                                                                }else{
                                                                    throw std::runtime_error("Const expr is not an integer literal in let statement: " + t3->pathFirst->pathSegments.identifier);   
                                                                }
                                                            }
                                                        }
                                                    }
                                                }else if(auto *t3 = dynamic_cast<ExprLiteral *>(& *t1->left)){
                                                    if(t3->type == INTEGER_LITERAL){
                                                        left_val = t3->integer;
                                                    }else{
                                                        throw std::runtime_error("Const expr is not an integer literal in let statement");   
                                                    }
                                                }
                                                if(auto *t3 = dynamic_cast<ExprPath *>(& *t1->right)){
                                                    if(t3->pathSecond == nullptr){
                                                        if(t3->pathFirst->pathSegments.type == IDENTIFIER) {    
                                                            auto symbol = current_scope->lookupValueSymbol(t3->pathFirst->pathSegments.identifier);
                                                            if(!symbol) {
                                                                throw std::runtime_error("Value symbol not found: " + t3->pathFirst->pathSegments.identifier);
                                                            }
                                                            if(symbol->symbol_type != Const) {
                                                                throw std::runtime_error("Value symbol is not a const: " + t3->pathFirst->pathSegments.identifier);
                                                            }
                                                            auto constSymbol = std::dynamic_pointer_cast<ConstSymbol>(symbol);
                                                            if(auto *u = dynamic_cast<ExprLiteral *>(& *constSymbol->value)){
                                                                if(u->type == INTEGER_LITERAL){
                                                                    right_val = u->integer;
                                                                }else{
                                                                    throw std::runtime_error("Const expr is not an integer literal in let statement: " + t3->pathFirst->pathSegments.identifier);   
                                                                }
                                                            }
                                                        }
                                                    }
                                                }else if(auto *t3 = dynamic_cast<ExprLiteral *>(& *t1->right)){
                                                    if(t3->type == INTEGER_LITERAL){
                                                        right_val = t3->integer;
                                                    }else{
                                                        throw std::runtime_error("Const expr is not an integer literal in let statement");   
                                                    }
                                                }
                                                if(left_val != -1 && right_val != -1){
                                                    if(t1->op == PLUS){
                                                        t1_size = left_val + right_val;
                                                    }else if(t1->op == MINUS){
                                                        t1_size = left_val - right_val;
                                                    }else if(t1->op == MULTIPLY){   
                                                        t1_size = left_val * right_val;
                                                    }else if(t1->op == DIVIDE){
                                                        if(right_val == 0){
                                                            throw std::runtime_error("Division by zero in const expr in let statement");
                                                        }
                                                        t1_size = left_val / right_val;
                                                    }
                                                }
                                            }
                                        }
                                        if(auto *t2 = dynamic_cast<ExprPath *>(& *o->expr)){
                                            if(t2->pathSecond == nullptr){
                                                if(t2->pathFirst->pathSegments.type == IDENTIFIER) {
                                                    auto symbol = current_scope->lookupValueSymbol(t2->pathFirst->pathSegments.identifier);
                                                    if(!symbol) {
                                                        throw std::runtime_error("Value symbol not found: " + t2->pathFirst->pathSegments.identifier);
                                                    }
                                                    if(symbol->symbol_type != Const) {
                                                        throw std::runtime_error("Value symbol is not a const: " + t2->pathFirst->pathSegments.identifier);
                                                    }
                                                    auto constSymbol = std::dynamic_pointer_cast<ConstSymbol>(symbol);
                                                    if(auto *u = dynamic_cast<ExprLiteral *>(& *constSymbol->value)){
                                                        if(u->type == INTEGER_LITERAL){
                                                            t2_size = u->integer;
                                                        }else{
                                                            throw std::runtime_error("Const expr is not an integer literal in let statement: " + t2->pathFirst->pathSegments.identifier);
                                                        }
                                                    }
                                                }
                                            }
                                        }else if(auto *t2 = dynamic_cast<ExprOpbinary *>(& *o->expr)){
                                            if(t2->op == PLUS || t2->op == MINUS || t2->op == MULTIPLY || t2->op == DIVIDE){
                                                int left_val2 = -1;
                                                int right_val2 = -1;
                                                if(auto *t3 = dynamic_cast<ExprPath *>(& *t2->left)){
                                                    if(t3->pathSecond == nullptr){
                                                        if(t3->pathFirst->pathSegments.type == IDENTIFIER) {
                                                            auto symbol = current_scope->lookupValueSymbol(t3->pathFirst->pathSegments.identifier);
                                                            if(!symbol) {
                                                                throw std::runtime_error("Value symbol not found: " + t3->pathFirst->pathSegments.identifier);
                                                            }
                                                            if(symbol->symbol_type != Const) {
                                                                throw std::runtime_error("Value symbol is not a const: " + t3->pathFirst->pathSegments.identifier);
                                                            }
                                                            auto constSymbol = std::dynamic_pointer_cast<ConstSymbol>(symbol);
                                                            if(auto *u = dynamic_cast<ExprLiteral *>(& *constSymbol->value)){
                                                                if(u->type == INTEGER_LITERAL){
                                                                    left_val2 = u->integer;
                                                                }else{
                                                                    throw std::runtime_error("Const expr is not an integer literal in let statement: " + t3->pathFirst->pathSegments.identifier);   
                                                                }
                                                            }
                                                        }
                                                    }
                                                }else if(auto *t3 = dynamic_cast<ExprLiteral *>(& *t2->left)){
                                                    if(t3->type == INTEGER_LITERAL){
                                                        left_val2 = t3->integer;
                                                    }else{
                                                        throw std::runtime_error("Const expr is not an integer literal in let statement");   
                                                    }
                                                }
                                                if(auto *t3 = dynamic_cast<ExprPath *>(& *t2->right)){
                                                    if(t3->pathSecond == nullptr){
                                                        if(t3->pathFirst->pathSegments.type == IDENTIFIER) {    
                                                            auto symbol = current_scope->lookupValueSymbol(t3->pathFirst->pathSegments.identifier);
                                                            if(!symbol) {
                                                                throw std::runtime_error("Value symbol not found: " + t3->pathFirst->pathSegments.identifier);
                                                            }
                                                            if(symbol->symbol_type != Const) {
                                                                throw std::runtime_error("Value symbol is not a const: " + t3->pathFirst->pathSegments.identifier);
                                                            }
                                                            auto constSymbol = std::dynamic_pointer_cast<ConstSymbol>(symbol);
                                                            if(auto *u = dynamic_cast<ExprLiteral *>(& *constSymbol->value)){
                                                                if(u->type == INTEGER_LITERAL){
                                                                    right_val2 = u->integer;
                                                                }else{
                                                                    throw std::runtime_error("Const expr is not an integer literal in let statement: "+ t3->pathFirst->pathSegments.identifier);  
                                                                }
                                                            }
                                                        }
                                                    }
                                                }else if(auto *t3 = dynamic_cast<ExprLiteral *>(& *t2->right)){
                                                    if(t3->type == INTEGER_LITERAL){
                                                        right_val2 = t3->integer;
                                                    }else{
                                                        throw std::runtime_error("Const expr is not an integer literal in let statement");   
                                                    }
                                                }
                                                if(left_val2 != -1 && right_val2 != -1){
                                                    if(t2->op == PLUS){
                                                        t2_size = left_val2 + right_val2;
                                                    }else if(t2->op == MINUS){
                                                        t2_size = left_val2 - right_val2;
                                                    }else if(t2->op == MULTIPLY){   
                                                        t2_size = left_val2 * right_val2;
                                                    }else if(t2->op == DIVIDE){
                                                        if(right_val2 == 0){
                                                            throw std::runtime_error("Division by zero in const expr in let statement");
                                                        }
                                                        t2_size = left_val2 / right_val2;
                                                    }
                                                }
                                            }
                                        }
                                        if(t1_size != -1 && t2_size != -1){
                                            if(t1_size != t2_size){
                                                throw std::runtime_error("Array size mismatch in let statement: " + p->pathFirst->pathSegments.identifier);
                                            }
                                        }
                                    }
                                }else{
                                    throw std::runtime_error("Type is not a simple type in let statement: " + p->pathFirst->pathSegments.identifier);
                                }
                            }else if(auto *r = dynamic_cast<TypeArray *>(& *q->type)){
                                if(auto *s = dynamic_cast<TypeArray *>(& *o->type)){
                                    if(auto *u1 = dynamic_cast<Type *>(& *r->type)){
                                        if(auto *u2 = dynamic_cast<Type *>(& *s->type)){
                                            if(u1->type != u2->type){
                                                throw std::runtime_error("Type mismatch in let statement: " + p->pathFirst->pathSegments.identifier);
                                            }else{
                                                if(auto *v1 = dynamic_cast<ExprLiteral *>(& *r->expr)){
                                                    if(auto *v2 = dynamic_cast<ExprLiteral *>(& *s->expr)){
                                                        if(v1->type == INTEGER_LITERAL && v2->type == INTEGER_LITERAL){
                                                            if(v1->integer != v2->integer){
                                                                throw std::runtime_error("Array size mismatch in let statement: " + p->pathFirst->pathSegments.identifier);
                                                            }
                                                        }else{
                                                            throw std::runtime_error("Array size is not an integer literal in let statement: " + p->pathFirst->pathSegments.identifier);
                                                        }
                                                    }
                                                }
                                            }
                                        }else{
                                            throw std::runtime_error("Type is not a simple type in let statement: " + p->pathFirst->pathSegments.identifier);
                                        }
                                    }
                                }else{
                                    throw std::runtime_error("Type is not an array type in let statement: " + p->pathFirst->pathSegments.identifier);
                                }
                            }else if(auto *r = dynamic_cast<Path *>(& *q->type)){
                                if(auto *s = dynamic_cast<Path *>(& *o->type)){
                                    if(r->pathSegments.type == IDENTIFIER && s->pathSegments.type == IDENTIFIER){
                                        if(r->pathSegments.identifier != s->pathSegments.identifier){
                                            throw std::runtime_error("Type mismatch in let statement: " + p->pathFirst->pathSegments.identifier);
                                        }
                                        auto symbol_r = current_scope->lookupTypeSymbol(r->pathSegments.identifier);
                                        if(!symbol_r) {
                                            throw std::runtime_error("Value symbol not found: " + r->pathSegments.identifier);
                                        }
                                        if(auto *t1 = dynamic_cast<ExprLiteral *>(& *q->expr)){
                                            if(auto *t2 = dynamic_cast<ExprLiteral *>(& *o->expr)){
                                                if(t1->type == INTEGER_LITERAL && t2->type == INTEGER_LITERAL){
                                                    if(t1->integer != t2->integer){
                                                        throw std::runtime_error("Array size mismatch in let statement: " + p->pathFirst->pathSegments.identifier);
                                                    }
                                                }else{
                                                    throw std::runtime_error("Array size is not an integer literal in let statement: " + p->pathFirst->pathSegments.identifier);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        //unary expr
        if(auto *p = dynamic_cast<ExprOpunary *>(& *node.expression)){
            if(p->op == DEREFERENCE){
                if(auto *q = dynamic_cast<ExprPath *>(& *p->right)){
                    if(q->pathSecond == nullptr){
                        if(q->pathFirst->pathSegments.type == IDENTIFIER) {
                            auto symbol = current_scope->lookupValueSymbol(q->pathFirst->pathSegments.identifier);
                            if(!symbol) {
                                throw std::runtime_error("Value symbol not found: " + q->pathFirst->pathSegments.identifier);
                            }
                            if(symbol->symbol_type != Variable) {
                                throw std::runtime_error("Value symbol is not a variable: " + q->pathFirst->pathSegments.identifier);
                            }
                            auto varSymbol = std::dynamic_pointer_cast<VariableSymbol>(symbol);
                            if(auto *r = dynamic_cast<TypeReference *>(& *varSymbol->type)){
                                if(auto *s = dynamic_cast<Type *>(& *r->typeNoBounds)){
                                    if(auto *t = dynamic_cast<Type *>(& *node.type)){
                                        if(s->type != t->type){
                                            throw std::runtime_error("Type mismatch in let statement: " + q->pathFirst->pathSegments.identifier);
                                        }
                                    }else{
                                        throw std::runtime_error("Type is not a simple type in let statement: " + q->pathFirst->pathSegments.identifier);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }


    //Type
    void visit(Type &node) override {}

    void visit(TypeArray &node) override{}
    
    void visit(TypePath &node) override{}

    void visit(TypeReference &node) override{}

    void visit(TypeUnit &node) override{}

    //Path
    void visit(Path &node) override{}
};
}